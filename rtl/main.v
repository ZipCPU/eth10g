`timescale	1ps / 1ps
////////////////////////////////////////////////////////////////////////////////
//
// Filename:	./main.v
// {{{
// Project:	10Gb Ethernet switch
//
// DO NOT EDIT THIS FILE!
// Computer Generated: This file is computer generated by AUTOFPGA. DO NOT EDIT.
// DO NOT EDIT THIS FILE!
//
// CmdLine:	autofpga -I .: -d -o . allclocks.txt siclk.txt sirefclk.txt global.txt wbdown.txt icape.txt version.txt gpio.txt spio.txt wbuconsole.txt zipmaster.txt bkram.txt ddr3.txt sdio.txt emmc.txt netrouter.txt cpunet.txt routescope.txt netscope.txt mem_bkram_only.txt mem_full.txt i2ccpu.txt fan.txt netclk.txt sirefclkcounter.txt
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
// }}}
// Copyright (C) 2023, Gisselquist Technology, LLC
// {{{
// This file is part of the ETH10G project.
//
// The ETH10G project contains free software and gateware, licensed under the
// terms of the 3rd version of the GNU General Public License as published by
// the Free Software Foundation.
//
// This project is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no
// target there if the PDF file isn't present.)  If not, see
// <http://www.gnu.org/licenses/> for a copy.
// }}}
// License:	GPL, v3, as defined and found on www.gnu.org,
// {{{
//		http://www.gnu.org/licenses/gpl.html
//
////////////////////////////////////////////////////////////////////////////////
//
// }}}
`default_nettype	none
////////////////////////////////////////////////////////////////////////////////
//
// Macro defines
// {{{
//
//
// Here is a list of defines which may be used, post auto-design
// (not post-build), to turn particular peripherals (and bus masters)
// on and off.  In particular, to turn off support for a particular
// design component, just comment out its respective `define below.
//
// These lines are taken from the respective @ACCESS tags for each of our
// components.  If a component doesn't have an @ACCESS tag, it will not
// be listed here.
//
// First, the independent access fields for any bus masters
`define	WBUBUS_MASTER
// And then for the independent peripherals
`define	REFCLKCOUNTER_ACCESS
`define	NETCLK_ACCESS
`define	FAN_ACCESS
`define	I2CCPU_ACCESS
`define	I2CDMA_ACCESS
`define	SPIO_ACCESS
`define	SDIO_ACCESS
`define	GPIO_ACCESS
`define	CFG_ACCESS
`define	VERSION_ACCESS
`define	INCLUDE_ZIPCPU
`define	SIREFCLK_ACCESS
`define	DDR3_PHY_ACCESS
`define	SICLK
`define	BUSCONSOLE_ACCESS
`define	EMMC_ACCESS
`define	BKRAM_ACCESS
`define	DDR3_CONTROLLER_ACCESS
`define	ETH_ROUTER
//
//
// The list of those things that have @DEPENDS tags
//
//
//
// Dependencies
// Any core with both an @ACCESS and a @DEPENDS tag will show up here.
// The @DEPENDS tag will turn into a series of ifdef's, with the @ACCESS
// being defined only if all of the ifdef's are true//
// Deplist for @$(PREFIX)=netscope
`ifdef	ETH_ROUTER
`define	NETSCOPE_SCOPC
`endif	// ETH_ROUTER
// Deplist for @$(PREFIX)=cpunet
`ifdef	ETH_ROUTER
`define	CPUNET_ACCESS
`endif	// ETH_ROUTER
// Deplist for @$(PREFIX)=netreset
`ifdef	ETH_ROUTER
`define	NETRESET_ACCESS
`endif	// ETH_ROUTER
// Deplist for @$(PREFIX)=routescope
`ifdef	ETH_ROUTER
`define	ROUTESCOPE_SCOPC
`endif	// ETH_ROUTER
//
// End of dependency list
//
//
// }}}
////////////////////////////////////////////////////////////////////////////////
//
// Any include files
// {{{
// These are drawn from anything with a MAIN.INCLUDE definition.
`include "builddate.v"
`define INCLUDE_DMA_CONTROLLER
`define INCLUDE_ACCOUNTING_COUNTERS
// }}}
//
// Finally, we define our main module itself.  We start with the list of
// I/O ports, or wires, passed into (or out of) the main function.
//
// These fields are copied verbatim from the respective I/O port lists,
// from the fields given by @MAIN.PORTLIST
//
module	main(i_clk, i_reset,
	// {{{
		i_sirefclk_clk,
			i_fan_sda, i_fan_scl,
			o_fan_sda, o_fan_scl,
			o_fpga_pwm, o_sys_pwm, i_fan_tach,
			i_i2c_sda, i_i2c_scl,
			o_i2c_sda, o_i2c_scl,
		// SPIO interface
		i_sw, i_btn, o_led,
		// SDIO SD Card
		i_sdio_detect,
		//
		o_sdio_cfg_ddr,
		o_sdio_cfg_ds,
		o_sdio_cfg_dscmd,
		o_sdio_cfg_sample_shift,
		o_sdio_pp_cmd,
		o_sdio_pp_data,
		//
		o_sdio_sdclk,
		o_sdio_cmd_en,
		o_sdio_cmd_data,
		o_sdio_data_en,
		o_sdio_rx_en,
		o_sdio_tx_data,
		//
		i_sdio_cmd_strb,
		i_sdio_cmd_data,
		i_sdio_card_busy,
		i_sdio_rx_strb,
		i_sdio_rx_data,
		//
		i_sdio_ac_valid,
		i_sdio_ac_data,
		i_sdio_ad_valid,
		i_sdio_ad_data,
		i_sdio_debug,
		// GPIO ports
		i_gpio, o_gpio,
		// UART/host to wishbone interface
		i_wbu_uart_rx, o_wbu_uart_tx,
		o_wbu_uart_cts_n,
		i_clk200,
		// Veri1ator only interface
		cpu_sim_cyc,
		cpu_sim_stb,
		cpu_sim_we,
		cpu_sim_addr,
		cpu_sim_data,
		cpu_sim_stall,
		cpu_sim_ack,
		cpu_sim_idata,
`ifdef	VERILATOR
		cpu_prof_stb,
		cpu_prof_addr,
		cpu_prof_ticks,
`endif
		i_cpu_reset,
		// Clock generator ports
		o_sirefclk_word, o_sirefclk_ce,
		i_siclk,
		// eMMC Card
		i_emmc_detect,
		//
		o_emmc_cfg_ddr,
		o_emmc_cfg_ds,
		o_emmc_cfg_dscmd,
		o_emmc_cfg_sample_shift,
		o_emmc_pp_cmd,
		o_emmc_pp_data,
		//
		o_emmc_sdclk,
		o_emmc_cmd_en,
		o_emmc_cmd_data,
		o_emmc_data_en,
		o_emmc_rx_en,
		o_emmc_tx_data,
		//
		i_emmc_cmd_strb,
		i_emmc_cmd_data,
		i_emmc_card_busy,
		i_emmc_rx_strb,
		i_emmc_rx_data,
		//
		i_emmc_ac_valid,
		i_emmc_ac_data,
		i_emmc_ad_valid,
		i_emmc_ad_data,
		i_emmc_debug,
		// DDR3 Controller Interface
		i_ddr3_controller_iserdes_data, i_ddr3_controller_iserdes_dqs,
		i_ddr3_controller_iserdes_bitslip_reference,
		i_ddr3_controller_idelayctrl_rdy,
		o_ddr3_controller_cmd,
		o_ddr3_controller_dqs_tri_control, o_ddr3_controller_dq_tri_control,
		o_ddr3_controller_toggle_dqs, o_ddr3_controller_data, o_ddr3_controller_dm,
		o_ddr3_controller_odelay_data_cntvaluein, o_ddr3_controller_odelay_dqs_cntvaluein,
		o_ddr3_controller_idelay_data_cntvaluein, o_ddr3_controller_idelay_dqs_cntvaluein,
		o_ddr3_controller_odelay_data_ld, o_ddr3_controller_odelay_dqs_ld,
		o_ddr3_controller_idelay_data_ld, o_ddr3_controller_idelay_dqs_ld,
		o_ddr3_controller_bitslip,
		o_ddr3_controller_leveling_calib,
		o_ddr3_controller_reset,
		i_gnet_rx_clk, i_gnet_rx_data,
		i_gnet_tx_clk, o_gnet_tx_data,
		i_gnet_phy_fault,o_gnet_linkup,o_gnet_activity,
		i_gnet_los, i_gnet_phy_locked
	// }}}
	);
////////////////////////////////////////////////////////////////////////////////
//
// Any parameter definitions
// {{{
// These are drawn from anything with a MAIN.PARAM definition.
// As they aren't connected to the toplevel at all, it would
// be best to use localparam over parameter, but here we don't
// check
	localparam	ICAPE_LGDIV=3;
	////////////////////////////////////////////////////////////////////////
	//
	// WBUBUS parameters
	// {{{
	// Baudrate :   1000000
	// Clock    : 100000000
	localparam [23:0] BUSUART = 24'h64;	//   1000000 baud
	localparam	DBGBUSBITS = $clog2(BUSUART);
	//
	// Maximum command is 6 bytes, where each byte takes 10 baud clocks
	// and each baud clock requires DBGBUSBITS to represent.  Here,
	// we'll add one more for good measure.
	localparam	DBGBUSWATCHDOG_RAW = DBGBUSBITS + 9;
	localparam	DBGBUSWATCHDOG = (DBGBUSWATCHDOG_RAW > 19)
				? DBGBUSWATCHDOG_RAW : 19;
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Variables/definitions/parameters used by the ZipCPU bus master
	// {{{
	//
	// A 32-bit address indicating where the ZipCPU should start running
	// from
`ifdef	BKROM_ACCESS
	localparam	RESET_ADDRESS = @$(/bkrom.BASE);
`else
`ifdef	FLASH_ACCESS
	localparam	RESET_ADDRESS = @$RESET_ADDRESS;
`else
	localparam	RESET_ADDRESS = 67108864;
`endif	// FLASH_ACCESS
`endif	// BKROM_ACCESS
	//
	// The number of valid bits on the bus
	localparam	ZIP_ADDRESS_WIDTH = 25; // Zip-CPU address width
	//
	// Number of ZipCPU interrupts
	localparam	ZIP_INTS = 16;
	//
	// ZIP_START_HALTED
	//
	// A boolean, indicating whether or not the ZipCPU be halted on startup?
`ifdef	BKROM_ACCESS
	localparam	ZIP_START_HALTED=1'b0;
`else
	localparam	ZIP_START_HALTED=1'b1;
`endif
	// }}}
    localparam real DDR3_CONTROLLERCONTROLLER_CLK_PERIOD = 10, //ns, period of clock input to this DDR3 controller module
                    DDR3_CLK_PERIOD = 2.5; //ns, period of clock input to DDR3 RAM device
    localparam      DDR3_CONTROLLERROW_BITS = 14,  // width of row address
                    DDR3_CONTROLLERCOL_BITS = 10,  // width of column address
                    DDR3_CONTROLLERBA_BITS  =  3,  // width of bank address
                    DDR3_CONTROLLERDQ_BITS  =  8,  // Size of one octet
                    DDR3_CONTROLLERLANES = 8, //8 lanes of DQ
                    DDR3_CONTROLLERAUX_WIDTH = 8, //must be 8 bits or more (also used in internal test and calibration)
                    DDR3_CONTROLLERSERDES_RATIO = $rtoi(DDR3_CONTROLLERCONTROLLER_CLK_PERIOD/DDR3_CLK_PERIOD),
                    //4 is the width of a single ddr3 command {cs_n, ras_n, cas_n, we_n} plus 3 (ck_en, odt, reset_n) plus bank bits plus row bits
                    DDR3_CONTROLLERCMD_LEN = 4 + 3 + DDR3_CONTROLLERBA_BITS + DDR3_CONTROLLERROW_BITS;


	localparam	NETDEVS  = 4;
`ifdef	CPUNET_ACCESS
	localparam	NETPORTS = 4+1;
`else
	localparam	NETPORTS = 4;
`endif
// }}}
////////////////////////////////////////////////////////////////////////////////
//
// Port declarations
// {{{
// The next step is to declare all of the various ports that were just
// listed above.  
//
// The following declarations are taken from the values of the various
// @MAIN.IODECL keys.
//
	input	wire		i_clk;
	// verilator lint_off UNUSED
	input	wire		i_reset;
	// verilator lint_on UNUSED
	input	wire	i_sirefclk_clk;
	// FAN Port declarations
	// {{{
	input	wire	i_fan_sda, i_fan_scl;
	output	wire	o_fan_sda, o_fan_scl;
	output	wire	o_fpga_pwm, o_sys_pwm;
	input	wire	i_fan_tach;
	// }}}
	// I2C Port declarations
	// {{{
	input	wire	i_i2c_sda, i_i2c_scl;
	output	wire	o_i2c_sda, o_i2c_scl;
	// }}}
	// SPIO interface
	input	wire	[8-1:0]	i_sw;
	input	wire	[5-1:0]	i_btn;
	output	wire	[8-1:0]	o_led;
	// SDIO SD Card declarations
	// {{{
	input	wire		i_sdio_detect;
		//
	output	wire		o_sdio_cfg_ddr;
	output	wire		o_sdio_cfg_ds;
	output	wire		o_sdio_cfg_dscmd;
	output	wire	[4:0]	o_sdio_cfg_sample_shift;
	output	wire		o_sdio_pp_cmd;
	output	wire		o_sdio_pp_data;
		//
	output	wire	[7:0]	o_sdio_sdclk;
	output	wire		o_sdio_cmd_en;
	output	wire	[1:0]	o_sdio_cmd_data;
	output	wire		o_sdio_data_en;
	output	wire		o_sdio_rx_en;
	output	wire	[31:0]	o_sdio_tx_data;
		//
	input	wire	[1:0]	i_sdio_cmd_strb;
	input	wire	[1:0]	i_sdio_cmd_data;
	input	wire		i_sdio_card_busy;
	input	wire	[1:0]	i_sdio_rx_strb;
	input	wire	[15:0]	i_sdio_rx_data;
		//
	input	wire		i_sdio_ac_valid;
	input	wire	[1:0]	i_sdio_ac_data;
	input	wire		i_sdio_ad_valid;
	input	wire	[31:0]	i_sdio_ad_data;
	// Verilator lint_off UNUSED
	input	wire	[31:0]	i_sdio_debug;
	// Verilator lint_on  UNUSED
	// }}}
	localparam	NGPI = 16, NGPO=8;
	// GPIO ports
	input	wire	[(NGPI-1):0]	i_gpio;
	output	wire	[(NGPO-1):0]	o_gpio;
	input	wire		i_wbu_uart_rx;
	output	wire		o_wbu_uart_tx;
	// input wire		i_wbu_uart_rts_n; // FT*'s perspective
	output wire		o_wbu_uart_cts_n;
	input	wire		cpu_sim_cyc, cpu_sim_stb;
	input	wire		cpu_sim_we;
	input	wire	[6:0]	cpu_sim_addr;
	input	wire	[31:0]	cpu_sim_data;
	//
	output	wire		cpu_sim_stall, cpu_sim_ack;
	output	wire	[31:0]	cpu_sim_idata;
	//
`ifdef	VERILATOR
	output	wire		cpu_prof_stb;
	output	wire	[25+$clog2(512/8)-1:0]	cpu_prof_addr;
	output	wire [31:0]	cpu_prof_ticks;
`endif
	input	wire		i_cpu_reset;
	output	wire	[7:0]	o_sirefclk_word;
	output	wire		o_sirefclk_ce;
	input	wire	i_siclk;
	// eMMC Card declarations
	// {{{
	input	wire		i_emmc_detect;
		//
	output	wire		o_emmc_cfg_ddr;
	output	wire		o_emmc_cfg_ds;
	output	wire		o_emmc_cfg_dscmd;
	output	wire	[4:0]	o_emmc_cfg_sample_shift;
	output	wire		o_emmc_pp_cmd;
	output	wire		o_emmc_pp_data;
		//
	output	wire	[7:0]	o_emmc_sdclk;
	output	wire		o_emmc_cmd_en;
	output	wire	[1:0]	o_emmc_cmd_data;
	output	wire		o_emmc_data_en;
	output	wire		o_emmc_rx_en;
	output	wire	[31:0]	o_emmc_tx_data;
		//
	input	wire	[1:0]	i_emmc_cmd_strb;
	input	wire	[1:0]	i_emmc_cmd_data;
	input	wire		i_emmc_card_busy;
	input	wire	[1:0]	i_emmc_rx_strb;
	input	wire	[15:0]	i_emmc_rx_data;
		//
	input	wire		i_emmc_ac_valid;
	input	wire	[1:0]	i_emmc_ac_data;
	input	wire		i_emmc_ad_valid;
	input	wire	[31:0]	i_emmc_ad_data;
	// Verilator lint_off UNUSED
	input	wire	[31:0]	i_emmc_debug;
	// Verilator lint_on  UNUSED
	// }}}
	// DDR3 Controller I/O declarations
	// {{{
	input wire    [DDR3_CONTROLLERDQ_BITS*DDR3_CONTROLLERLANES*8-1:0] i_ddr3_controller_iserdes_data;
	input wire    [DDR3_CONTROLLERLANES*8-1:0] i_ddr3_controller_iserdes_dqs;
	input wire    [DDR3_CONTROLLERLANES*8-1:0] i_ddr3_controller_iserdes_bitslip_reference;
	input wire    i_ddr3_controller_idelayctrl_rdy;
	output wire    [DDR3_CONTROLLERCMD_LEN*DDR3_CONTROLLERSERDES_RATIO-1:0] o_ddr3_controller_cmd;
	output wire    o_ddr3_controller_dqs_tri_control, o_ddr3_controller_dq_tri_control;
	output wire    o_ddr3_controller_toggle_dqs;
	output wire    [DDR3_CONTROLLERDQ_BITS*DDR3_CONTROLLERLANES*8-1:0] o_ddr3_controller_data;
	output wire    [(DDR3_CONTROLLERDQ_BITS*DDR3_CONTROLLERLANES*8)/8-1:0] o_ddr3_controller_dm;
	output wire    [4:0] o_ddr3_controller_odelay_data_cntvaluein, o_ddr3_controller_odelay_dqs_cntvaluein;
	output wire    [4:0] o_ddr3_controller_idelay_data_cntvaluein, o_ddr3_controller_idelay_dqs_cntvaluein;
	output wire    [DDR3_CONTROLLERLANES-1:0] o_ddr3_controller_odelay_data_ld, o_ddr3_controller_odelay_dqs_ld;
	output wire    [DDR3_CONTROLLERLANES-1:0] o_ddr3_controller_idelay_data_ld, o_ddr3_controller_idelay_dqs_ld;
	output wire    [DDR3_CONTROLLERLANES-1:0] o_ddr3_controller_bitslip;
	output wire    o_ddr3_controller_leveling_calib;
	output wire    o_ddr3_controller_reset;
	// }}}
	// 10Gb Ethernet
	// {{{
	input	wire	[NETDEVS-1:0]	i_gnet_rx_clk;
	input	wire [32*NETDEVS-1:0]	i_gnet_rx_data;
	input	wire	[NETDEVS-1:0]	i_gnet_tx_clk;
	output	wire [32*NETDEVS-1:0]	o_gnet_tx_data;
	input	wire	[NETDEVS-1:0]	i_gnet_phy_fault;
	output	wire [NETDEVS-1:0]	o_gnet_linkup;
	output	wire [NETDEVS-1:0]	o_gnet_activity;
	// Verilator lint_off UNUSED
	input	wire	[NETDEVS-1:0]	i_gnet_los;
	input	wire	[NETDEVS:0]	i_gnet_phy_locked;
	// Verilator lint_on  UNUSED
	// }}}
// }}}
	// Make Verilator happy
	// {{{
	// Defining bus wires for lots of components often ends up with unused
	// wires lying around.  We'll turn off Ver1lator's lint warning
	// here that checks for unused wires.
	// }}}
	// verilator lint_off UNUSED
	////////////////////////////////////////////////////////////////////////
	//
	// Declaring interrupt lines
	// {{{
	// These declarations come from the various components values
	// given under the @INT.<interrupt name>.WIRE key.
	//
	wire	spio_int;	// spio.INT.SPIO.WIRE
	wire	sdio_int;	// sdio.INT.SDCARD.WIRE
	wire	gpio_int;	// gpio.INT.GPIO.WIRE
	wire	uartrxf_int;	// uart.INT.UARTRXF.WIRE
	wire	uarttx_int;	// uart.INT.UARTTX.WIRE
	wire	uarttxf_int;	// uart.INT.UARTTXF.WIRE
	wire	uartrx_int;	// uart.INT.UARTRX.WIRE
	wire	emmc_int;	// emmc.INT.EMMC.WIRE
	wire	cpunet_tx_int;	// cpunet.INT.TXNET.WIRE
	wire	cpunet_rx_int;	// cpunet.INT.RXNET.WIRE
	wire	routescope_int;	// routescope.INT.ROUTESCOPE.WIRE
	wire	netscope_int;	// netscope.INT.NETSCOPE.WIRE
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Component declarations
	// {{{
	// These declarations come from the @MAIN.DEFNS keys found in the
	// various components comprising the design.
	//
	genvar	g_netclk;
	wire	[31:0]	w_netclk_rxcounter	[0:4-1];
	wire	[31:0]	w_netclk_txcounter;
	reg		r_netclk_ack;
	reg	[31:0]	r_netclk_data;
	// FAN/fan Controller
	// {{{
	// Verilator lint_off UNUSED
	wire	[31:0]	fan_debug;
	// Verilator lint_on  UNUSED
	// }}}
	// I2C Controller
	// {{{
	// Verilator lint_off UNUSED
	localparam	I2C_ID_WIDTH=(2 == 0) ? 1 : 2;

	wire		i2c_valid, i2c_ready, i2c_last;
	wire	[7:0]	i2c_data;
	wire	[I2C_ID_WIDTH-1:0]	i2c_id;

	wire	[31:0]	i2c_debug;
	// Verilator lint_on  UNUSED
	// }}}
	wire	i2cdma_ready;
	wire	[8-1:0]	w_led;
	// SDIO SD Card definitions
	// Verilator lint_off UNUSED
	wire		w_sdio_1p8v;
	wire	[31:0]	sdio_debug;
	assign		sdio_debug = i_sdio_debug;
	// Verilator lint_on  UNUSED
	// Verilator lint_off	UNUSED
	wire	[31:0]	cfg_debug;
	// Verilator lint_on 	UNUSED
	////////////////////////////////////////////////////////////////////////
	//
	// WBUBUS: USB-UART interface declarations
	// {{{
	//
	wire	[7:0]	wbu_rx_data, wbu_tx_data;
	wire		wbu_rx_stb;
	wire		wbu_tx_stb, wbu_tx_busy;

	// Definitions for the WB-UART converter.  We really only need one
	// (more) non-bus wire--one to use to select if we are interacting
	// with the ZipCPU or not.
	// Verilator lint_off UNUSED
	wire	[0:0]	wbubus_dbg;
	// Verilator lint_on  UNUSED
	// }}}
	// Verilator lint_off UNUSED
	input	wire	i_clk200;
	// Verilator lint_on  UNUSED
	////////////////////////////////////////////////////////////////////////
	//
	// ZipSystem/ZipCPU connection definitions
	// {{{
`ifndef	VERILATOR
	wire		cpu_prof_stb;
	wire	[25+$clog2(512/8)-1:0]	cpu_prof_addr;
	wire [31:0]	cpu_prof_ticks;
`endif
	// All we define here is a set of scope wires
	// Verilator lint_off UNUSED
	wire		raw_cpu_dbg_stall, raw_cpu_dbg_ack;
	wire	[31:0]	zip_debug;
	wire		zip_trigger;
	// Verilator lint_on  UNUSED
	wire	[ZIP_INTS-1:0] zip_int_vector;
	wire		zip_cpu_int;
	// }}}
	reg		r_sirefclk_en;
	reg	[29:0]	r_sirefclk_data;
	wire		w_sirefclk_unused_stb;
	reg		r_sirefclk_ack;
	reg	[3:0]	r_netlock_los;
	reg	[4:0]	r_netlock_phy_locked;
// BUILDTIME doesnt need to include builddate.v a second time
// `include "builddate.v"
	////////////////////////////////////////////////////////////////////////
	//
	// WBUBUS: Console definitions
	// {{{
	wire		w_console_rx_stb, w_console_tx_stb, w_console_busy;
	wire	[6:0]	w_console_rx_data, w_console_tx_data;
	// Verilator lint_off UNUSED
	wire	[31:0]	uart_debug;
	// Verilator lint_on  UNUSED
	// }}}
	// eMMC Card definitions
	// Verilator lint_off UNUSED
	wire		w_emmc_1p8v;
	wire	[31:0]	emmc_debug;
	assign		emmc_debug = i_emmc_debug;
	// Verilator lint_on  UNUSED
	// Verilator lint_off UNUSED
	wire	[DDR3_CONTROLLERAUX_WIDTH-1:0]	ddr3_controller_aux_out;
	wire	[31:0]	ddr3_controller_debug1, ddr3_controller_debug2, ddr3_controller_debug3;
	// Verilator lint_on  UNUSED
	reg	[NETPORTS-1:0]	r_netreset;
	// Incoming 10Gb packet signaling
	// {{{
	wire	[NETDEVS-1:0]		gnet_rx_valid,
					gnet_rx_ready,
					gnet_rx_last,
					gnet_rx_abort;
	wire	[128*NETDEVS-1:0]	gnet_rx_data;
	wire	[4*NETDEVS-1:0]	gnet_rx_bytes;
	// }}}
	// Outoging 10Gb packet signaling
	// {{{
	wire	[NETDEVS-1:0]		gnet_tx_valid,
					gnet_tx_ready,
					gnet_tx_last,
					gnet_tx_abort;
	wire	[128*NETDEVS-1:0]	gnet_tx_data;
	wire	[4*NETDEVS-1:0]	gnet_tx_bytes;
	// }}}
	genvar	g_gnet;
	// Verilator lint_off UNUSED
	wire	[32*NETDEVS-1:0]	gnet_net_debug;
	wire	[32-1:0]		gnet_route_debug;
	// Verilator lint_on  UNUSED
	// CPUNet Controller
	// {{{
	// Verilator lint_off UNUSED
	wire		cpunet_rx_valid,
			cpunet_rx_ready,
			cpunet_rx_last,
			cpunet_rx_abort;
	wire	[127:0]	cpunet_rx_data;
	wire	[3:0]	cpunet_rx_bytes;

	wire		cpunet_tx_valid,
			cpunet_tx_ready,
			cpunet_tx_last,
			cpunet_tx_abort;
	wire	[127:0]	cpunet_tx_data;
	wire	[3:0]	cpunet_tx_bytes;

	wire	[31:0]	cpunet_debug;
	// Verilator lint_on  UNUSED
	// }}}
	reg	[$clog2(NETDEVS)-1:0]	netdbg_netdbg;
	reg	[31:0]	net_debug;
	reg	[2*NETDEVS-1:0]		netdbg_netleds;
	// Verilator lint_off UNUSED
	wire	[32*NETDEVS-1:0]	netdbg_wide;
	// Verilator lint_on  UNUSED

// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Declaring interrupt vector wires
	// {{{
	// These declarations come from the various components having
	// PIC and PIC.MAX keys.
	//
	wire	[14:0]	alt_int_vector;
	wire	[14:0]	sys_int_vector;
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Declare bus signals
	// {{{
	////////////////////////////////////////////////////////////////////////

	// Bus wbwide
	// {{{
	// Wishbone definitions for bus wbwide, component i2c
	// Verilator lint_off UNUSED
	wire		wbwide_i2cm_cyc, wbwide_i2cm_stb, wbwide_i2cm_we;
	wire	[24:0]	wbwide_i2cm_addr;
	wire	[511:0]	wbwide_i2cm_data;
	wire	[63:0]	wbwide_i2cm_sel;
	wire		wbwide_i2cm_stall, wbwide_i2cm_ack, wbwide_i2cm_err;
	wire	[511:0]	wbwide_i2cm_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component i2cdma
	// Verilator lint_off UNUSED
	wire		wbwide_i2cdma_cyc, wbwide_i2cdma_stb, wbwide_i2cdma_we;
	wire	[24:0]	wbwide_i2cdma_addr;
	wire	[511:0]	wbwide_i2cdma_data;
	wire	[63:0]	wbwide_i2cdma_sel;
	wire		wbwide_i2cdma_stall, wbwide_i2cdma_ack, wbwide_i2cdma_err;
	wire	[511:0]	wbwide_i2cdma_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component wbu_arbiter
	// Verilator lint_off UNUSED
	wire		wbwide_wbu_arbiter_cyc, wbwide_wbu_arbiter_stb, wbwide_wbu_arbiter_we;
	wire	[24:0]	wbwide_wbu_arbiter_addr;
	wire	[511:0]	wbwide_wbu_arbiter_data;
	wire	[63:0]	wbwide_wbu_arbiter_sel;
	wire		wbwide_wbu_arbiter_stall, wbwide_wbu_arbiter_ack, wbwide_wbu_arbiter_err;
	wire	[511:0]	wbwide_wbu_arbiter_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component zip
	// Verilator lint_off UNUSED
	wire		wbwide_zip_cyc, wbwide_zip_stb, wbwide_zip_we;
	wire	[24:0]	wbwide_zip_addr;
	wire	[511:0]	wbwide_zip_data;
	wire	[63:0]	wbwide_zip_sel;
	wire		wbwide_zip_stall, wbwide_zip_ack, wbwide_zip_err;
	wire	[511:0]	wbwide_zip_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component gnet
	// Verilator lint_off UNUSED
	wire		wbwide_gnet_cyc, wbwide_gnet_stb, wbwide_gnet_we;
	wire	[24:0]	wbwide_gnet_addr;
	wire	[511:0]	wbwide_gnet_data;
	wire	[63:0]	wbwide_gnet_sel;
	wire		wbwide_gnet_stall, wbwide_gnet_ack, wbwide_gnet_err;
	wire	[511:0]	wbwide_gnet_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component cpunet
	// Verilator lint_off UNUSED
	wire		wbwide_cpunetm_cyc, wbwide_cpunetm_stb, wbwide_cpunetm_we;
	wire	[24:0]	wbwide_cpunetm_addr;
	wire	[511:0]	wbwide_cpunetm_data;
	wire	[63:0]	wbwide_cpunetm_sel;
	wire		wbwide_cpunetm_stall, wbwide_cpunetm_ack, wbwide_cpunetm_err;
	wire	[511:0]	wbwide_cpunetm_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component wbdown
	// Verilator lint_off UNUSED
	wire		wbwide_wbdown_cyc, wbwide_wbdown_stb, wbwide_wbdown_we;
	wire	[24:0]	wbwide_wbdown_addr;
	wire	[511:0]	wbwide_wbdown_data;
	wire	[63:0]	wbwide_wbdown_sel;
	wire		wbwide_wbdown_stall, wbwide_wbdown_ack, wbwide_wbdown_err;
	wire	[511:0]	wbwide_wbdown_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component bkram
	// Verilator lint_off UNUSED
	wire		wbwide_bkram_cyc, wbwide_bkram_stb, wbwide_bkram_we;
	wire	[24:0]	wbwide_bkram_addr;
	wire	[511:0]	wbwide_bkram_data;
	wire	[63:0]	wbwide_bkram_sel;
	wire		wbwide_bkram_stall, wbwide_bkram_ack, wbwide_bkram_err;
	wire	[511:0]	wbwide_bkram_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbwide, component ddr3_controller
	// Verilator lint_off UNUSED
	wire		wbwide_ddr3_controller_cyc, wbwide_ddr3_controller_stb, wbwide_ddr3_controller_we;
	wire	[24:0]	wbwide_ddr3_controller_addr;
	wire	[511:0]	wbwide_ddr3_controller_data;
	wire	[63:0]	wbwide_ddr3_controller_sel;
	wire		wbwide_ddr3_controller_stall, wbwide_ddr3_controller_ack, wbwide_ddr3_controller_err;
	wire	[511:0]	wbwide_ddr3_controller_idata;
	// Verilator lint_on UNUSED
	// }}}
	// Bus wb32
	// {{{
	// Wishbone definitions for bus wb32, component wbdown
	// Verilator lint_off UNUSED
	wire		wb32_wbdown_cyc, wb32_wbdown_stb, wb32_wbdown_we;
	wire	[8:0]	wb32_wbdown_addr;
	wire	[31:0]	wb32_wbdown_data;
	wire	[3:0]	wb32_wbdown_sel;
	wire		wb32_wbdown_stall, wb32_wbdown_ack, wb32_wbdown_err;
	wire	[31:0]	wb32_wbdown_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component buildtime
	// Verilator lint_off UNUSED
	wire		wb32_buildtime_cyc, wb32_buildtime_stb, wb32_buildtime_we;
	wire	[8:0]	wb32_buildtime_addr;
	wire	[31:0]	wb32_buildtime_data;
	wire	[3:0]	wb32_buildtime_sel;
	wire		wb32_buildtime_stall, wb32_buildtime_ack, wb32_buildtime_err;
	wire	[31:0]	wb32_buildtime_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component gpio
	// Verilator lint_off UNUSED
	wire		wb32_gpio_cyc, wb32_gpio_stb, wb32_gpio_we;
	wire	[8:0]	wb32_gpio_addr;
	wire	[31:0]	wb32_gpio_data;
	wire	[3:0]	wb32_gpio_sel;
	wire		wb32_gpio_stall, wb32_gpio_ack, wb32_gpio_err;
	wire	[31:0]	wb32_gpio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component netdbg
	// Verilator lint_off UNUSED
	wire		wb32_netdbg_cyc, wb32_netdbg_stb, wb32_netdbg_we;
	wire	[8:0]	wb32_netdbg_addr;
	wire	[31:0]	wb32_netdbg_data;
	wire	[3:0]	wb32_netdbg_sel;
	wire		wb32_netdbg_stall, wb32_netdbg_ack, wb32_netdbg_err;
	wire	[31:0]	wb32_netdbg_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component netlock
	// Verilator lint_off UNUSED
	wire		wb32_netlock_cyc, wb32_netlock_stb, wb32_netlock_we;
	wire	[8:0]	wb32_netlock_addr;
	wire	[31:0]	wb32_netlock_data;
	wire	[3:0]	wb32_netlock_sel;
	wire		wb32_netlock_stall, wb32_netlock_ack, wb32_netlock_err;
	wire	[31:0]	wb32_netlock_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component netreset
	// Verilator lint_off UNUSED
	wire		wb32_netreset_cyc, wb32_netreset_stb, wb32_netreset_we;
	wire	[8:0]	wb32_netreset_addr;
	wire	[31:0]	wb32_netreset_data;
	wire	[3:0]	wb32_netreset_sel;
	wire		wb32_netreset_stall, wb32_netreset_ack, wb32_netreset_err;
	wire	[31:0]	wb32_netreset_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component siclk
	// Verilator lint_off UNUSED
	wire		wb32_siclk_cyc, wb32_siclk_stb, wb32_siclk_we;
	wire	[8:0]	wb32_siclk_addr;
	wire	[31:0]	wb32_siclk_data;
	wire	[3:0]	wb32_siclk_sel;
	wire		wb32_siclk_stall, wb32_siclk_ack, wb32_siclk_err;
	wire	[31:0]	wb32_siclk_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component sirefclk
	// Verilator lint_off UNUSED
	wire		wb32_sirefclk_cyc, wb32_sirefclk_stb, wb32_sirefclk_we;
	wire	[8:0]	wb32_sirefclk_addr;
	wire	[31:0]	wb32_sirefclk_data;
	wire	[3:0]	wb32_sirefclk_sel;
	wire		wb32_sirefclk_stall, wb32_sirefclk_ack, wb32_sirefclk_err;
	wire	[31:0]	wb32_sirefclk_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component sirefclkcounter
	// Verilator lint_off UNUSED
	wire		wb32_sirefclkcounter_cyc, wb32_sirefclkcounter_stb, wb32_sirefclkcounter_we;
	wire	[8:0]	wb32_sirefclkcounter_addr;
	wire	[31:0]	wb32_sirefclkcounter_data;
	wire	[3:0]	wb32_sirefclkcounter_sel;
	wire		wb32_sirefclkcounter_stall, wb32_sirefclkcounter_ack, wb32_sirefclkcounter_err;
	wire	[31:0]	wb32_sirefclkcounter_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component spio
	// Verilator lint_off UNUSED
	wire		wb32_spio_cyc, wb32_spio_stb, wb32_spio_we;
	wire	[8:0]	wb32_spio_addr;
	wire	[31:0]	wb32_spio_data;
	wire	[3:0]	wb32_spio_sel;
	wire		wb32_spio_stall, wb32_spio_ack, wb32_spio_err;
	wire	[31:0]	wb32_spio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(SIO), component version
	// Verilator lint_off UNUSED
	wire		wb32_version_cyc, wb32_version_stb, wb32_version_we;
	wire	[8:0]	wb32_version_addr;
	wire	[31:0]	wb32_version_data;
	wire	[3:0]	wb32_version_sel;
	wire		wb32_version_stall, wb32_version_ack, wb32_version_err;
	wire	[31:0]	wb32_version_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(DIO), component i2c
	// Verilator lint_off UNUSED
	wire		wb32_i2cs_cyc, wb32_i2cs_stb, wb32_i2cs_we;
	wire	[8:0]	wb32_i2cs_addr;
	wire	[31:0]	wb32_i2cs_data;
	wire	[3:0]	wb32_i2cs_sel;
	wire		wb32_i2cs_stall, wb32_i2cs_ack, wb32_i2cs_err;
	wire	[31:0]	wb32_i2cs_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(DIO), component i2cdma
	// Verilator lint_off UNUSED
	wire		wb32_i2cdma_cyc, wb32_i2cdma_stb, wb32_i2cdma_we;
	wire	[8:0]	wb32_i2cdma_addr;
	wire	[31:0]	wb32_i2cdma_data;
	wire	[3:0]	wb32_i2cdma_sel;
	wire		wb32_i2cdma_stall, wb32_i2cdma_ack, wb32_i2cdma_err;
	wire	[31:0]	wb32_i2cdma_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(DIO), component netclk
	// Verilator lint_off UNUSED
	wire		wb32_netclk_cyc, wb32_netclk_stb, wb32_netclk_we;
	wire	[8:0]	wb32_netclk_addr;
	wire	[31:0]	wb32_netclk_data;
	wire	[3:0]	wb32_netclk_sel;
	wire		wb32_netclk_stall, wb32_netclk_ack, wb32_netclk_err;
	wire	[31:0]	wb32_netclk_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32(DIO), component wb32_sio
	// Verilator lint_off UNUSED
	wire		wb32_sio_cyc, wb32_sio_stb, wb32_sio_we;
	wire	[8:0]	wb32_sio_addr;
	wire	[31:0]	wb32_sio_data;
	wire	[3:0]	wb32_sio_sel;
	wire		wb32_sio_stall, wb32_sio_ack, wb32_sio_err;
	wire	[31:0]	wb32_sio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component netscope
	// Verilator lint_off UNUSED
	wire		wb32_netscope_cyc, wb32_netscope_stb, wb32_netscope_we;
	wire	[8:0]	wb32_netscope_addr;
	wire	[31:0]	wb32_netscope_data;
	wire	[3:0]	wb32_netscope_sel;
	wire		wb32_netscope_stall, wb32_netscope_ack, wb32_netscope_err;
	wire	[31:0]	wb32_netscope_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component routescope
	// Verilator lint_off UNUSED
	wire		wb32_routescope_cyc, wb32_routescope_stb, wb32_routescope_we;
	wire	[8:0]	wb32_routescope_addr;
	wire	[31:0]	wb32_routescope_data;
	wire	[3:0]	wb32_routescope_sel;
	wire		wb32_routescope_stall, wb32_routescope_ack, wb32_routescope_err;
	wire	[31:0]	wb32_routescope_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component uart
	// Verilator lint_off UNUSED
	wire		wb32_uart_cyc, wb32_uart_stb, wb32_uart_we;
	wire	[8:0]	wb32_uart_addr;
	wire	[31:0]	wb32_uart_data;
	wire	[3:0]	wb32_uart_sel;
	wire		wb32_uart_stall, wb32_uart_ack, wb32_uart_err;
	wire	[31:0]	wb32_uart_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component emmc
	// Verilator lint_off UNUSED
	wire		wb32_emmc_cyc, wb32_emmc_stb, wb32_emmc_we;
	wire	[8:0]	wb32_emmc_addr;
	wire	[31:0]	wb32_emmc_data;
	wire	[3:0]	wb32_emmc_sel;
	wire		wb32_emmc_stall, wb32_emmc_ack, wb32_emmc_err;
	wire	[31:0]	wb32_emmc_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component fan
	// Verilator lint_off UNUSED
	wire		wb32_fan_cyc, wb32_fan_stb, wb32_fan_we;
	wire	[8:0]	wb32_fan_addr;
	wire	[31:0]	wb32_fan_data;
	wire	[3:0]	wb32_fan_sel;
	wire		wb32_fan_stall, wb32_fan_ack, wb32_fan_err;
	wire	[31:0]	wb32_fan_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component sdio
	// Verilator lint_off UNUSED
	wire		wb32_sdio_cyc, wb32_sdio_stb, wb32_sdio_we;
	wire	[8:0]	wb32_sdio_addr;
	wire	[31:0]	wb32_sdio_data;
	wire	[3:0]	wb32_sdio_sel;
	wire		wb32_sdio_stall, wb32_sdio_ack, wb32_sdio_err;
	wire	[31:0]	wb32_sdio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component cfg
	// Verilator lint_off UNUSED
	wire		wb32_cfg_cyc, wb32_cfg_stb, wb32_cfg_we;
	wire	[8:0]	wb32_cfg_addr;
	wire	[31:0]	wb32_cfg_data;
	wire	[3:0]	wb32_cfg_sel;
	wire		wb32_cfg_stall, wb32_cfg_ack, wb32_cfg_err;
	wire	[31:0]	wb32_cfg_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component cpunet
	// Verilator lint_off UNUSED
	wire		wb32_cpunets_cyc, wb32_cpunets_stb, wb32_cpunets_we;
	wire	[8:0]	wb32_cpunets_addr;
	wire	[31:0]	wb32_cpunets_data;
	wire	[3:0]	wb32_cpunets_sel;
	wire		wb32_cpunets_stall, wb32_cpunets_ack, wb32_cpunets_err;
	wire	[31:0]	wb32_cpunets_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component wb32_dio
	// Verilator lint_off UNUSED
	wire		wb32_dio_cyc, wb32_dio_stb, wb32_dio_we;
	wire	[8:0]	wb32_dio_addr;
	wire	[31:0]	wb32_dio_data;
	wire	[3:0]	wb32_dio_sel;
	wire		wb32_dio_stall, wb32_dio_ack, wb32_dio_err;
	wire	[31:0]	wb32_dio_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component gnet
	// Verilator lint_off UNUSED
	wire		wb32_gnet_cyc, wb32_gnet_stb, wb32_gnet_we;
	wire	[8:0]	wb32_gnet_addr;
	wire	[31:0]	wb32_gnet_data;
	wire	[3:0]	wb32_gnet_sel;
	wire		wb32_gnet_stall, wb32_gnet_ack, wb32_gnet_err;
	wire	[31:0]	wb32_gnet_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wb32, component ddr3_phy
	// Verilator lint_off UNUSED
	wire		wb32_ddr3_phy_cyc, wb32_ddr3_phy_stb, wb32_ddr3_phy_we;
	wire	[8:0]	wb32_ddr3_phy_addr;
	wire	[31:0]	wb32_ddr3_phy_data;
	wire	[3:0]	wb32_ddr3_phy_sel;
	wire		wb32_ddr3_phy_stall, wb32_ddr3_phy_ack, wb32_ddr3_phy_err;
	wire	[31:0]	wb32_ddr3_phy_idata;
	// Verilator lint_on UNUSED
	// }}}
	// Bus wbu
	// {{{
	// Wishbone definitions for bus wbu, component wbu
	// Verilator lint_off UNUSED
	wire		wbu_cyc, wbu_stb, wbu_we;
	wire	[29:0]	wbu_addr;
	wire	[31:0]	wbu_data;
	wire	[3:0]	wbu_sel;
	wire		wbu_stall, wbu_ack, wbu_err;
	wire	[31:0]	wbu_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbu, component wbu_arbiter
	// Verilator lint_off UNUSED
	wire		wbu_wbu_arbiter_cyc, wbu_wbu_arbiter_stb, wbu_wbu_arbiter_we;
	wire	[29:0]	wbu_wbu_arbiter_addr;
	wire	[31:0]	wbu_wbu_arbiter_data;
	wire	[3:0]	wbu_wbu_arbiter_sel;
	wire		wbu_wbu_arbiter_stall, wbu_wbu_arbiter_ack, wbu_wbu_arbiter_err;
	wire	[31:0]	wbu_wbu_arbiter_idata;
	// Verilator lint_on UNUSED
	// Wishbone definitions for bus wbu, component zip
	// Verilator lint_off UNUSED
	wire		wbu_zip_cyc, wbu_zip_stb, wbu_zip_we;
	wire	[29:0]	wbu_zip_addr;
	wire	[31:0]	wbu_zip_data;
	wire	[3:0]	wbu_zip_sel;
	wire		wbu_zip_stall, wbu_zip_ack, wbu_zip_err;
	wire	[31:0]	wbu_zip_idata;
	// Verilator lint_on UNUSED
	// }}}
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Peripheral address decoding, bus handling
	// {{{
	//
	// BUS-LOGIC for wbwide
	// {{{
	//
	// No class SINGLE peripherals on the "wbwide" bus
	//

	//
	// No class DOUBLE peripherals on the "wbwide" bus
	//

	// info: @ERROR.WIRE for wbdown matches the buses error name, wbwide_wbdown_err
	assign	wbwide_bkram_err= 1'b0;
	assign	wbwide_ddr3_controller_err= 1'b0;
	//
	// Connect the wbwide bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(6), .NS(3), .AW(25), .DW(512),
		.SLAVE_ADDR({
			// Address width    = 25
			// Address LSBs     = 6
			{ 25'h1000000 }, // ddr3_controller: 0x40000000
			{ 25'h0100000 }, //           bkram: 0x04000000
			{ 25'h0080000 }  //          wbdown: 0x02000000
		}),
		.SLAVE_MASK({
			// Address width    = 25
			// Address LSBs     = 6
			{ 25'h1000000 }, // ddr3_controller
			{ 25'h1f80000 }, //           bkram
			{ 25'h1f80000 }  //          wbdown
		}),
		.OPT_DBLBUFFER(1'b1))
	wbwide_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			wbwide_cpunetm_cyc,
			wbwide_gnet_cyc,
			wbwide_zip_cyc,
			wbwide_wbu_arbiter_cyc,
			wbwide_i2cdma_cyc,
			wbwide_i2cm_cyc
		}),
		.i_mstb({
			wbwide_cpunetm_stb,
			wbwide_gnet_stb,
			wbwide_zip_stb,
			wbwide_wbu_arbiter_stb,
			wbwide_i2cdma_stb,
			wbwide_i2cm_stb
		}),
		.i_mwe({
			wbwide_cpunetm_we,
			wbwide_gnet_we,
			wbwide_zip_we,
			wbwide_wbu_arbiter_we,
			wbwide_i2cdma_we,
			wbwide_i2cm_we
		}),
		.i_maddr({
			wbwide_cpunetm_addr,
			wbwide_gnet_addr,
			wbwide_zip_addr,
			wbwide_wbu_arbiter_addr,
			wbwide_i2cdma_addr,
			wbwide_i2cm_addr
		}),
		.i_mdata({
			wbwide_cpunetm_data,
			wbwide_gnet_data,
			wbwide_zip_data,
			wbwide_wbu_arbiter_data,
			wbwide_i2cdma_data,
			wbwide_i2cm_data
		}),
		.i_msel({
			wbwide_cpunetm_sel,
			wbwide_gnet_sel,
			wbwide_zip_sel,
			wbwide_wbu_arbiter_sel,
			wbwide_i2cdma_sel,
			wbwide_i2cm_sel
		}),
		.o_mstall({
			wbwide_cpunetm_stall,
			wbwide_gnet_stall,
			wbwide_zip_stall,
			wbwide_wbu_arbiter_stall,
			wbwide_i2cdma_stall,
			wbwide_i2cm_stall
		}),
		.o_mack({
			wbwide_cpunetm_ack,
			wbwide_gnet_ack,
			wbwide_zip_ack,
			wbwide_wbu_arbiter_ack,
			wbwide_i2cdma_ack,
			wbwide_i2cm_ack
		}),
		.o_mdata({
			wbwide_cpunetm_idata,
			wbwide_gnet_idata,
			wbwide_zip_idata,
			wbwide_wbu_arbiter_idata,
			wbwide_i2cdma_idata,
			wbwide_i2cm_idata
		}),
		.o_merr({
			wbwide_cpunetm_err,
			wbwide_gnet_err,
			wbwide_zip_err,
			wbwide_wbu_arbiter_err,
			wbwide_i2cdma_err,
			wbwide_i2cm_err
		}),
		// Slave connections
		.o_scyc({
			wbwide_ddr3_controller_cyc,
			wbwide_bkram_cyc,
			wbwide_wbdown_cyc
		}),
		.o_sstb({
			wbwide_ddr3_controller_stb,
			wbwide_bkram_stb,
			wbwide_wbdown_stb
		}),
		.o_swe({
			wbwide_ddr3_controller_we,
			wbwide_bkram_we,
			wbwide_wbdown_we
		}),
		.o_saddr({
			wbwide_ddr3_controller_addr,
			wbwide_bkram_addr,
			wbwide_wbdown_addr
		}),
		.o_sdata({
			wbwide_ddr3_controller_data,
			wbwide_bkram_data,
			wbwide_wbdown_data
		}),
		.o_ssel({
			wbwide_ddr3_controller_sel,
			wbwide_bkram_sel,
			wbwide_wbdown_sel
		}),
		.i_sstall({
			wbwide_ddr3_controller_stall,
			wbwide_bkram_stall,
			wbwide_wbdown_stall
		}),
		.i_sack({
			wbwide_ddr3_controller_ack,
			wbwide_bkram_ack,
			wbwide_wbdown_ack
		}),
		.i_sdata({
			wbwide_ddr3_controller_idata,
			wbwide_bkram_idata,
			wbwide_wbdown_idata
		}),
		.i_serr({
			wbwide_ddr3_controller_err,
			wbwide_bkram_err,
			wbwide_wbdown_err
		})
		);

	// End of bus logic for wbwide
	// }}}
	//
	// BUS-LOGIC for wb32
	// {{{
	//
	// wb32 Bus logic to handle SINGLE slaves
	//
	reg		r_wb32_sio_ack;
	reg	[31:0]	r_wb32_sio_data;

	assign	wb32_sio_stall = 1'b0;

	initial r_wb32_sio_ack = 1'b0;
	always	@(posedge i_clk)
		r_wb32_sio_ack <= (wb32_sio_stb);
	assign	wb32_sio_ack = r_wb32_sio_ack;

	always	@(posedge i_clk)
	casez( wb32_sio_addr[3:0] )
	4'h0: r_wb32_sio_data <= wb32_buildtime_idata;
	4'h1: r_wb32_sio_data <= wb32_gpio_idata;
	4'h2: r_wb32_sio_data <= wb32_netdbg_idata;
	4'h3: r_wb32_sio_data <= wb32_netlock_idata;
	4'h4: r_wb32_sio_data <= wb32_netreset_idata;
	4'h5: r_wb32_sio_data <= wb32_siclk_idata;
	4'h6: r_wb32_sio_data <= wb32_sirefclk_idata;
	4'h7: r_wb32_sio_data <= wb32_sirefclkcounter_idata;
	4'h8: r_wb32_sio_data <= wb32_spio_idata;
	4'h9: r_wb32_sio_data <= wb32_version_idata;
	default: r_wb32_sio_data <= wb32_version_idata;
	endcase
	assign	wb32_sio_idata = r_wb32_sio_data;


	//
	// Now to translate this logic to the various SIO slaves
	//
	// In this case, the SIO bus has the prefix wb32_sio
	// and all of the slaves have various wires beginning
	// with their own respective bus prefixes.
	// Our goal here is to make certain that all of
	// the slave bus inputs match the SIO bus wires
	assign	wb32_buildtime_cyc = wb32_sio_cyc;
	assign	wb32_buildtime_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h0);  // 0x000
	assign	wb32_buildtime_we  = wb32_sio_we;
	assign	wb32_buildtime_data= wb32_sio_data;
	assign	wb32_buildtime_sel = wb32_sio_sel;
	assign	wb32_gpio_cyc = wb32_sio_cyc;
	assign	wb32_gpio_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h1);  // 0x004
	assign	wb32_gpio_we  = wb32_sio_we;
	assign	wb32_gpio_data= wb32_sio_data;
	assign	wb32_gpio_sel = wb32_sio_sel;
	assign	wb32_netdbg_cyc = wb32_sio_cyc;
	assign	wb32_netdbg_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h2);  // 0x008
	assign	wb32_netdbg_we  = wb32_sio_we;
	assign	wb32_netdbg_data= wb32_sio_data;
	assign	wb32_netdbg_sel = wb32_sio_sel;
	assign	wb32_netlock_cyc = wb32_sio_cyc;
	assign	wb32_netlock_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h3);  // 0x00c
	assign	wb32_netlock_we  = wb32_sio_we;
	assign	wb32_netlock_data= wb32_sio_data;
	assign	wb32_netlock_sel = wb32_sio_sel;
	assign	wb32_netreset_cyc = wb32_sio_cyc;
	assign	wb32_netreset_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h4);  // 0x010
	assign	wb32_netreset_we  = wb32_sio_we;
	assign	wb32_netreset_data= wb32_sio_data;
	assign	wb32_netreset_sel = wb32_sio_sel;
	assign	wb32_siclk_cyc = wb32_sio_cyc;
	assign	wb32_siclk_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h5);  // 0x014
	assign	wb32_siclk_we  = wb32_sio_we;
	assign	wb32_siclk_data= wb32_sio_data;
	assign	wb32_siclk_sel = wb32_sio_sel;
	assign	wb32_sirefclk_cyc = wb32_sio_cyc;
	assign	wb32_sirefclk_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h6);  // 0x018
	assign	wb32_sirefclk_we  = wb32_sio_we;
	assign	wb32_sirefclk_data= wb32_sio_data;
	assign	wb32_sirefclk_sel = wb32_sio_sel;
	assign	wb32_sirefclkcounter_cyc = wb32_sio_cyc;
	assign	wb32_sirefclkcounter_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h7);  // 0x01c
	assign	wb32_sirefclkcounter_we  = wb32_sio_we;
	assign	wb32_sirefclkcounter_data= wb32_sio_data;
	assign	wb32_sirefclkcounter_sel = wb32_sio_sel;
	assign	wb32_spio_cyc = wb32_sio_cyc;
	assign	wb32_spio_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h8);  // 0x020
	assign	wb32_spio_we  = wb32_sio_we;
	assign	wb32_spio_data= wb32_sio_data;
	assign	wb32_spio_sel = wb32_sio_sel;
	assign	wb32_version_cyc = wb32_sio_cyc;
	assign	wb32_version_stb = wb32_sio_stb && (wb32_sio_addr[ 3: 0] ==  4'h9);  // 0x024
	assign	wb32_version_we  = wb32_sio_we;
	assign	wb32_version_data= wb32_sio_data;
	assign	wb32_version_sel = wb32_sio_sel;
	//
	// wb32 Bus logic to handle 4 DOUBLE slaves
	//
	//
	reg	[1:0]	r_wb32_dio_ack;
	// # dlist = 4, nextlg(#dlist) = 2
	reg	[1:0]	r_wb32_dio_bus_select;
	reg	[31:0]	r_wb32_dio_data;

	// DOUBLE peripherals are not allowed to stall.
	assign	wb32_dio_stall = 1'b0;

	// DOUBLE peripherals return their acknowledgments in two
	// clocks--always, allowing us to collect this logic together
	// in a slave independent manner.  Here, the acknowledgment
	// is treated as a two stage shift register, cleared on any
	// reset, or any time the cycle line drops.  (Dropping the
	// cycle line aborts the transaction.)
	initial	r_wb32_dio_ack = 0;
	always	@(posedge i_clk)
	if (i_reset || !wb32_dio_cyc)
		r_wb32_dio_ack <= 0;
	else
		r_wb32_dio_ack <= { r_wb32_dio_ack[0], (wb32_dio_stb) };
	assign	wb32_dio_ack = r_wb32_dio_ack[1];

	// Since it costs us two clocks to go through this
	// logic, we'll take one of those clocks here to set
	// a selection index, and then on the next clock we'll
	// use this index to select from among the vaious
	// possible bus return values
	always @(posedge i_clk)
	casez(wb32_dio_addr[4:2])
	3'b000: r_wb32_dio_bus_select <= 2'd0;
	3'b001: r_wb32_dio_bus_select <= 2'd1;
	3'b01?: r_wb32_dio_bus_select <= 2'd2;
	3'b1??: r_wb32_dio_bus_select <= 2'd3;
	default: r_wb32_dio_bus_select <= 0;
	endcase

	always	@(posedge i_clk)
	casez(r_wb32_dio_bus_select)
	2'd0: r_wb32_dio_data <= wb32_i2cs_idata;
	2'd1: r_wb32_dio_data <= wb32_i2cdma_idata;
	2'd2: r_wb32_dio_data <= wb32_netclk_idata;
	2'd3: r_wb32_dio_data <= wb32_sio_idata;
	endcase

	assign	wb32_dio_idata = r_wb32_dio_data;

	assign	wb32_i2cs_cyc = wb32_dio_cyc;
	assign	wb32_i2cs_stb = wb32_dio_stb && ((wb32_dio_addr[ 4: 2] &  3'h7) ==  3'h0);  // 0x000 - 0x00f
	assign	wb32_i2cs_we  = wb32_dio_we;
	assign	wb32_i2cs_addr= wb32_dio_addr;
	assign	wb32_i2cs_data= wb32_dio_data;
	assign	wb32_i2cs_sel = wb32_dio_sel;
	assign	wb32_i2cdma_cyc = wb32_dio_cyc;
	assign	wb32_i2cdma_stb = wb32_dio_stb && ((wb32_dio_addr[ 4: 2] &  3'h7) ==  3'h1);  // 0x010 - 0x01f
	assign	wb32_i2cdma_we  = wb32_dio_we;
	assign	wb32_i2cdma_addr= wb32_dio_addr;
	assign	wb32_i2cdma_data= wb32_dio_data;
	assign	wb32_i2cdma_sel = wb32_dio_sel;
	assign	wb32_netclk_cyc = wb32_dio_cyc;
	assign	wb32_netclk_stb = wb32_dio_stb && ((wb32_dio_addr[ 4: 2] &  3'h6) ==  3'h2);  // 0x020 - 0x033
	assign	wb32_netclk_we  = wb32_dio_we;
	assign	wb32_netclk_addr= wb32_dio_addr;
	assign	wb32_netclk_data= wb32_dio_data;
	assign	wb32_netclk_sel = wb32_dio_sel;
	assign	wb32_sio_cyc = wb32_dio_cyc;
	assign	wb32_sio_stb = wb32_dio_stb && ((wb32_dio_addr[ 4: 2] &  3'h4) ==  3'h4);  // 0x040 - 0x07f
	assign	wb32_sio_we  = wb32_dio_we;
	assign	wb32_sio_addr= wb32_dio_addr;
	assign	wb32_sio_data= wb32_dio_data;
	assign	wb32_sio_sel = wb32_dio_sel;
	assign	wb32_netscope_err= 1'b0;
	assign	wb32_routescope_err= 1'b0;
	assign	wb32_uart_err= 1'b0;
	assign	wb32_emmc_err= 1'b0;
	assign	wb32_fan_err= 1'b0;
	assign	wb32_sdio_err= 1'b0;
	assign	wb32_cfg_err= 1'b0;
	assign	wb32_cpunets_err= 1'b0;
	assign	wb32_dio_err= 1'b0;
	assign	wb32_gnet_err= 1'b0;
	assign	wb32_ddr3_phy_err= 1'b0;
	//
	// Connect the wb32 bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(1), .NS(11), .AW(9), .DW(32),
		.SLAVE_ADDR({
			// Address width    = 9
			// Address LSBs     = 2
			{ 9'h180 }, //   ddr3_phy: 0x600
			{ 9'h140 }, //       gnet: 0x500
			{ 9'h100 }, //   wb32_dio: 0x400
			{ 9'h0e0 }, //     cpunet: 0x380
			{ 9'h0c0 }, //        cfg: 0x300
			{ 9'h0a0 }, //       sdio: 0x280
			{ 9'h080 }, //        fan: 0x200
			{ 9'h060 }, //       emmc: 0x180
			{ 9'h040 }, //       uart: 0x100
			{ 9'h020 }, // routescope: 0x080
			{ 9'h000 }  //   netscope: 0x000
		}),
		.SLAVE_MASK({
			// Address width    = 9
			// Address LSBs     = 2
			{ 9'h180 }, //   ddr3_phy
			{ 9'h1c0 }, //       gnet
			{ 9'h1e0 }, //   wb32_dio
			{ 9'h1e0 }, //     cpunet
			{ 9'h1e0 }, //        cfg
			{ 9'h1e0 }, //       sdio
			{ 9'h1e0 }, //        fan
			{ 9'h1e0 }, //       emmc
			{ 9'h1e0 }, //       uart
			{ 9'h1e0 }, // routescope
			{ 9'h1e0 }  //   netscope
		}),
		.OPT_DBLBUFFER(1'b1))
	wb32_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			wb32_wbdown_cyc
		}),
		.i_mstb({
			wb32_wbdown_stb
		}),
		.i_mwe({
			wb32_wbdown_we
		}),
		.i_maddr({
			wb32_wbdown_addr
		}),
		.i_mdata({
			wb32_wbdown_data
		}),
		.i_msel({
			wb32_wbdown_sel
		}),
		.o_mstall({
			wb32_wbdown_stall
		}),
		.o_mack({
			wb32_wbdown_ack
		}),
		.o_mdata({
			wb32_wbdown_idata
		}),
		.o_merr({
			wb32_wbdown_err
		}),
		// Slave connections
		.o_scyc({
			wb32_ddr3_phy_cyc,
			wb32_gnet_cyc,
			wb32_dio_cyc,
			wb32_cpunets_cyc,
			wb32_cfg_cyc,
			wb32_sdio_cyc,
			wb32_fan_cyc,
			wb32_emmc_cyc,
			wb32_uart_cyc,
			wb32_routescope_cyc,
			wb32_netscope_cyc
		}),
		.o_sstb({
			wb32_ddr3_phy_stb,
			wb32_gnet_stb,
			wb32_dio_stb,
			wb32_cpunets_stb,
			wb32_cfg_stb,
			wb32_sdio_stb,
			wb32_fan_stb,
			wb32_emmc_stb,
			wb32_uart_stb,
			wb32_routescope_stb,
			wb32_netscope_stb
		}),
		.o_swe({
			wb32_ddr3_phy_we,
			wb32_gnet_we,
			wb32_dio_we,
			wb32_cpunets_we,
			wb32_cfg_we,
			wb32_sdio_we,
			wb32_fan_we,
			wb32_emmc_we,
			wb32_uart_we,
			wb32_routescope_we,
			wb32_netscope_we
		}),
		.o_saddr({
			wb32_ddr3_phy_addr,
			wb32_gnet_addr,
			wb32_dio_addr,
			wb32_cpunets_addr,
			wb32_cfg_addr,
			wb32_sdio_addr,
			wb32_fan_addr,
			wb32_emmc_addr,
			wb32_uart_addr,
			wb32_routescope_addr,
			wb32_netscope_addr
		}),
		.o_sdata({
			wb32_ddr3_phy_data,
			wb32_gnet_data,
			wb32_dio_data,
			wb32_cpunets_data,
			wb32_cfg_data,
			wb32_sdio_data,
			wb32_fan_data,
			wb32_emmc_data,
			wb32_uart_data,
			wb32_routescope_data,
			wb32_netscope_data
		}),
		.o_ssel({
			wb32_ddr3_phy_sel,
			wb32_gnet_sel,
			wb32_dio_sel,
			wb32_cpunets_sel,
			wb32_cfg_sel,
			wb32_sdio_sel,
			wb32_fan_sel,
			wb32_emmc_sel,
			wb32_uart_sel,
			wb32_routescope_sel,
			wb32_netscope_sel
		}),
		.i_sstall({
			wb32_ddr3_phy_stall,
			wb32_gnet_stall,
			wb32_dio_stall,
			wb32_cpunets_stall,
			wb32_cfg_stall,
			wb32_sdio_stall,
			wb32_fan_stall,
			wb32_emmc_stall,
			wb32_uart_stall,
			wb32_routescope_stall,
			wb32_netscope_stall
		}),
		.i_sack({
			wb32_ddr3_phy_ack,
			wb32_gnet_ack,
			wb32_dio_ack,
			wb32_cpunets_ack,
			wb32_cfg_ack,
			wb32_sdio_ack,
			wb32_fan_ack,
			wb32_emmc_ack,
			wb32_uart_ack,
			wb32_routescope_ack,
			wb32_netscope_ack
		}),
		.i_sdata({
			wb32_ddr3_phy_idata,
			wb32_gnet_idata,
			wb32_dio_idata,
			wb32_cpunets_idata,
			wb32_cfg_idata,
			wb32_sdio_idata,
			wb32_fan_idata,
			wb32_emmc_idata,
			wb32_uart_idata,
			wb32_routescope_idata,
			wb32_netscope_idata
		}),
		.i_serr({
			wb32_ddr3_phy_err,
			wb32_gnet_err,
			wb32_dio_err,
			wb32_cpunets_err,
			wb32_cfg_err,
			wb32_sdio_err,
			wb32_fan_err,
			wb32_emmc_err,
			wb32_uart_err,
			wb32_routescope_err,
			wb32_netscope_err
		})
		);

	// End of bus logic for wb32
	// }}}
	//
	// BUS-LOGIC for wbu
	// {{{
	//
	// No class SINGLE peripherals on the "wbu" bus
	//

	//
	// No class DOUBLE peripherals on the "wbu" bus
	//

	// info: @ERROR.WIRE for wbu_arbiter matches the buses error name, wbu_wbu_arbiter_err
	assign	wbu_zip_err= 1'b0;
	//
	// Connect the wbu bus components together using the wbxbar()
	//
	//
	wbxbar #(
		.NM(1), .NS(2), .AW(30), .DW(32),
		.SLAVE_ADDR({
			// Address width    = 30
			// Address LSBs     = 2
			{ 30'h20000000 }, //         zip: 0x80000000
			{ 30'h00000000 }  // wbu_arbiter: 0x00000000
		}),
		.SLAVE_MASK({
			// Address width    = 30
			// Address LSBs     = 2
			{ 30'h38000000 }, //         zip
			{ 30'h20000000 }  // wbu_arbiter
		}),
		.OPT_DBLBUFFER(1'b1))
	wbu_xbar(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_mcyc({
			wbu_cyc
		}),
		.i_mstb({
			wbu_stb
		}),
		.i_mwe({
			wbu_we
		}),
		.i_maddr({
			wbu_addr
		}),
		.i_mdata({
			wbu_data
		}),
		.i_msel({
			wbu_sel
		}),
		.o_mstall({
			wbu_stall
		}),
		.o_mack({
			wbu_ack
		}),
		.o_mdata({
			wbu_idata
		}),
		.o_merr({
			wbu_err
		}),
		// Slave connections
		.o_scyc({
			wbu_zip_cyc,
			wbu_wbu_arbiter_cyc
		}),
		.o_sstb({
			wbu_zip_stb,
			wbu_wbu_arbiter_stb
		}),
		.o_swe({
			wbu_zip_we,
			wbu_wbu_arbiter_we
		}),
		.o_saddr({
			wbu_zip_addr,
			wbu_wbu_arbiter_addr
		}),
		.o_sdata({
			wbu_zip_data,
			wbu_wbu_arbiter_data
		}),
		.o_ssel({
			wbu_zip_sel,
			wbu_wbu_arbiter_sel
		}),
		.i_sstall({
			wbu_zip_stall,
			wbu_wbu_arbiter_stall
		}),
		.i_sack({
			wbu_zip_ack,
			wbu_wbu_arbiter_ack
		}),
		.i_sdata({
			wbu_zip_idata,
			wbu_wbu_arbiter_idata
		}),
		.i_serr({
			wbu_zip_err,
			wbu_wbu_arbiter_err
		})
		);

	// End of bus logic for wbu
	// }}}
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Declare the interrupt busses
	// {{{
	// Interrupt busses are defined by anything with a @PIC tag.
	// The @PIC.BUS tag defines the name of the wire bus below,
	// while the @PIC.MAX tag determines the size of the bus width.
	//
	// For your peripheral to be assigned to this bus, it must have an
	// @INT.NAME.WIRE= tag to define the wire name of the interrupt line,
	// and an @INT.NAME.PIC= tag matching the @PIC.BUS tag of the bus
	// your interrupt will be assigned to.  If an @INT.NAME.ID tag also
	// exists, then your interrupt will be assigned to the position given
	// by the ID# in that tag.
	//
	assign	alt_int_vector = {
		1'b0,
		netscope_int,
		routescope_int,
		emmc_int,
		uartrx_int,
		uarttx_int,
		gpio_int,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0
	};
	assign	sys_int_vector = {
		1'b0,
		1'b0,
		1'b0,
		cpunet_rx_int,
		cpunet_tx_int,
		uarttxf_int,
		uartrxf_int,
		sdio_int,
		spio_int,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0
	};
	// }}}
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//
	// @MAIN.INSERT and @MAIN.ALT
	// {{{
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//
	//
	// Now we turn to defining all of the parts and pieces of what
	// each of the various peripherals does, and what logic it needs.
	//
	// This information comes from the @MAIN.INSERT and @MAIN.ALT tags.
	// If an @ACCESS tag is available, an ifdef is created to handle
	// having the access and not.  If the @ACCESS tag is `defined above
	// then the @MAIN.INSERT code is executed.  If not, the @MAIN.ALT
	// code is exeucted, together with any other cleanup settings that
	// might need to take place--such as returning zeros to the bus,
	// or making sure all of the various interrupt wires are set to
	// zero if the component is not included.
	//
`ifdef	REFCLKCOUNTER_ACCESS
	// {{{
	clkcounter
	u_sirefclkcounter (
		.i_sys_clk(i_clk), .i_tst_clk(i_sirefclk_clk),
		.i_sys_pps(1'b0), .o_sys_counts(wb32_sirefclkcounter_idata)
	);
	// }}}
`else	// REFCLKCOUNTER_ACCESS
	// {{{
	// }}}
`endif	// REFCLKCOUNTER_ACCESS

`ifdef	NETCLK_ACCESS
	// {{{
	generate for(g_netclk=0; g_netclk<4; g_netclk=g_netclk+1)
	begin : MEASURE_NETCLK

		clkcounter
		u_rxnetclk (
			.i_sys_clk(i_clk), .i_tst_clk(i_gnet_rx_clk[g_netclk]),
			.i_sys_pps(1'b0),
			.o_sys_counts(w_netclk_rxcounter[g_netclk])
		);

	end endgenerate

	clkcounter
	u_txnetclk (
		.i_sys_clk(i_clk), .i_tst_clk(i_gnet_tx_clk[0]),
		.i_sys_pps(1'b0), .o_sys_counts(w_netclk_txcounter)
	);

	always @(posedge i_clk)
	begin
		if (wb32_netclk_addr[2:0] < 4)
			r_netclk_data <= w_netclk_rxcounter[
				wb32_netclk_addr[1:0]];
		else
			r_netclk_data <= w_netclk_txcounter;

		if (!wb32_netclk_stb)
			r_netclk_data <= 0;
	end

	assign	wb32_netclk_stall = 0;
	always @(posedge i_clk)
		r_netclk_ack <= wb32_netclk_stb;
	assign	wb32_netclk_idata = r_netclk_data;
	// }}}
`else	// NETCLK_ACCESS
	// {{{
	// }}}
`endif	// NETCLK_ACCESS

`ifdef	FAN_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// The FAN Controller: fan
	// {{{

	wbfan
	u_fan (
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		.i_wb_cyc(wb32_fan_cyc), .i_wb_stb(wb32_fan_stb), .i_wb_we(wb32_fan_we),
			.i_wb_addr(wb32_fan_addr[3-1:0]),
			.i_wb_data(wb32_fan_data), // 32 bits wide
			.i_wb_sel(wb32_fan_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_fan_stall),.o_wb_ack(wb32_fan_ack), .o_wb_data(wb32_fan_idata),
		.i_temp_sda(i_fan_sda), .i_temp_scl(i_fan_scl),
		.o_temp_sda(o_fan_sda), .o_temp_scl(o_fan_scl),
		//
		.o_fpga_pwm(o_fpga_pwm), .o_sys_pwm(o_sys_pwm),
		.i_fan_tach(i_fan_tach),
		//
		.temp_debug(fan_debug)
		// }}}
	);
	// }}}
	// }}}
`else	// FAN_ACCESS
	// {{{
	assign	o_fan_scl = 1'b1;
	assign	o_fan_sda = 1'b1;
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_fan peripheral
	// responding on the wb32 bus
	assign	wb32_fan_ack   = 1'b0;
	assign	wb32_fan_err   = (wb32_fan_stb);
	assign	wb32_fan_stall = 0;
	assign	wb32_fan_idata = 0;

	// }}}
	// }}}
`endif	// FAN_ACCESS

`ifdef	I2CCPU_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// The I2C Controller
	// {{{

	wbi2ccpu #(
		.ADDRESS_WIDTH(25),
		.DATA_WIDTH(512),
		.AXIS_ID_WIDTH(2)
	) i2ci (
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_i2cs_cyc), .i_wb_stb(wb32_i2cs_stb), .i_wb_we(wb32_i2cs_we),
			.i_wb_addr(wb32_i2cs_addr[2-1:0]),
			.i_wb_data(wb32_i2cs_data), // 32 bits wide
			.i_wb_sel(wb32_i2cs_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_i2cs_stall),.o_wb_ack(wb32_i2cs_ack), .o_wb_data(wb32_i2cs_idata),
		.o_pf_cyc(wbwide_i2cm_cyc), .o_pf_stb(wbwide_i2cm_stb), .o_pf_we(wbwide_i2cm_we),
			.o_pf_addr(wbwide_i2cm_addr[25-1:0]),
			.o_pf_data(wbwide_i2cm_data), // 512 bits wide
			.o_pf_sel(wbwide_i2cm_sel),  // 512/8 bits wide
		.i_pf_stall(wbwide_i2cm_stall), .i_pf_ack(wbwide_i2cm_ack), .i_pf_data(wbwide_i2cm_idata), .i_pf_err(wbwide_i2cm_err),
		.i_i2c_sda(i_i2c_sda), .i_i2c_scl(i_i2c_scl),
		.o_i2c_sda(o_i2c_sda), .o_i2c_scl(o_i2c_scl),
		.M_AXIS_TVALID(i2c_valid), .M_AXIS_TREADY(i2c_ready),
			.M_AXIS_TDATA(i2c_data), .M_AXIS_TLAST(i2c_last),
			.M_AXIS_TID(i2c_id),
		.i_sync_signal(1'b0),
		//
		.o_debug(i2c_debug)
		// }}}
	);

	assign	i2c_ready = (!i2c_valid) || (1'b0
			|| (i2c_id == 0)		// NULL address
`ifdef	EDID_ACCESS
			|| (i2c_id == 1 && edid_ready)
`else
			|| (i2c_id == 1)
`endif
`ifdef	I2CDMA_ACCESS
			|| (i2c_id == 2 && i2cdma_ready)
`else
			|| (i2c_id == 2)
`endif
			|| (i2c_id > 2));

	// }}}
	// }}}
`else	// I2CCPU_ACCESS
	// {{{
	assign	o_i2c_scl = 1'b1;
	assign	o_i2c_sda = 1'b1;
	// Null bus master
	// {{{
	// }}}
	// }}}
`endif	// I2CCPU_ACCESS

`ifdef	I2CDMA_ACCESS
	// {{{
	wbi2cdma #(
		.AW(25), .DW(512), .SW(8),
		.OPT_LITTLE_ENDIAN(1'b0)
	) u_i2cdma (
		.i_clk(i_clk),
		.i_reset(i_reset),
		//
		.i_wb_cyc(wb32_i2cdma_cyc), .i_wb_stb(wb32_i2cdma_stb), .i_wb_we(wb32_i2cdma_we),
			.i_wb_addr(wb32_i2cdma_addr[2-1:0]),
			.i_wb_data(wb32_i2cdma_data), // 32 bits wide
			.i_wb_sel(wb32_i2cdma_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_i2cdma_stall),.o_wb_ack(wb32_i2cdma_ack), .o_wb_data(wb32_i2cdma_idata),
		.S_VALID(i2c_valid && i2c_id == 2), .S_READY(i2cdma_ready),
			.S_DATA(i2c_data), .S_LAST(i2c_last),
		.o_dma_cyc(wbwide_i2cdma_cyc), .o_dma_stb(wbwide_i2cdma_stb), .o_dma_we(wbwide_i2cdma_we),
			.o_dma_addr(wbwide_i2cdma_addr[25-1:0]),
			.o_dma_data(wbwide_i2cdma_data), // 512 bits wide
			.o_dma_sel(wbwide_i2cdma_sel),  // 512/8 bits wide
		.i_dma_stall(wbwide_i2cdma_stall), .i_dma_ack(wbwide_i2cdma_ack), .i_dma_data(wbwide_i2cdma_idata), .i_dma_err(wbwide_i2cdma_err)
	);

	// }}}
`else	// I2CDMA_ACCESS
	// {{{
	assign	@$(prefix)_ready = 1'b0;
	// Null bus master
	// {{{
	// }}}
	// }}}
`endif	// I2CDMA_ACCESS

	////////////////////////////////////////////////////////////////////////
	//
	// WBUBUS "wbu_arbiter" master->slave connection
	// {{{
	wbupsz #(
		// {{{
		.ADDRESS_WIDTH(25+$clog2(512/8)),
		.SMALL_DW(32),
		.WIDE_DW(512),
		.OPT_LITTLE_ENDIAN(1'b0)
		// }}}
	) wbu_arbiter_upsz (
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		.i_scyc(wbu_wbu_arbiter_cyc), .i_sstb(wbu_wbu_arbiter_stb), .i_swe(wbu_wbu_arbiter_we),
			.i_saddr(wbu_wbu_arbiter_addr[29-1:0]),
			.i_sdata(wbu_wbu_arbiter_data), // 32 bits wide
			.i_ssel(wbu_wbu_arbiter_sel),  // 32/8 bits wide
		.o_sstall(wbu_wbu_arbiter_stall),.o_sack(wbu_wbu_arbiter_ack), .o_sdata(wbu_wbu_arbiter_idata), .o_serr(wbu_wbu_arbiter_err),
		.o_wcyc(wbwide_wbu_arbiter_cyc), .o_wstb(wbwide_wbu_arbiter_stb), .o_wwe(wbwide_wbu_arbiter_we),
			.o_waddr(wbwide_wbu_arbiter_addr[25-1:0]),
			.o_wdata(wbwide_wbu_arbiter_data), // 512 bits wide
			.o_wsel(wbwide_wbu_arbiter_sel),  // 512/8 bits wide
		.i_wstall(wbwide_wbu_arbiter_stall), .i_wack(wbwide_wbu_arbiter_ack), .i_wdata(wbwide_wbu_arbiter_idata), .i_werr(wbwide_wbu_arbiter_err)
		// }}}
	);
	// }}}
`ifdef	SPIO_ACCESS
	// {{{
	//
	// Special purpose I/O driver (buttons, LEDs, and switches)
	//

	spio #(
		.NBTN(5), .NLEDS(8), .NSW(8)
	) spioi(
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_spio_cyc), .i_wb_stb(wb32_spio_stb), .i_wb_we(wb32_spio_we),
			.i_wb_data(wb32_spio_data), // 32 bits wide
			.i_wb_sel(wb32_spio_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_spio_stall),.o_wb_ack(wb32_spio_ack), .o_wb_data(wb32_spio_idata),
		.i_sw(i_sw), .i_btn(i_btn), .o_led(w_led),
		.o_int(spio_int)
	);

	assign	o_led = w_led;

	// }}}
`else	// SPIO_ACCESS
	// {{{
	assign	w_btn = 0;
	assign	o_led = 0;
	// Null interrupt definitions
	// {{{
	assign	spio_int = 1'b0;	// spio.INT.SPIO.WIRE
	// }}}
	// }}}
`endif	// SPIO_ACCESS

`ifdef	SDIO_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// SDIO SD Card handling
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	//

	sdio #(
		// {{{
		.LGFIFO(10), .NUMIO(4),
		.MW(32),
		.OPT_SERDES(1'b0),
		.OPT_DDR(1'b1),
		.OPT_CARD_DETECT(1'b1),
		.OPT_EMMC(1'b0)
		// }}}
	) u_sdio(
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		.i_wb_cyc(wb32_sdio_cyc), .i_wb_stb(wb32_sdio_stb), .i_wb_we(wb32_sdio_we),
			.i_wb_addr(wb32_sdio_addr[3-1:0]),
			.i_wb_data(wb32_sdio_data), // 32 bits wide
			.i_wb_sel(wb32_sdio_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_sdio_stall),.o_wb_ack(wb32_sdio_ack), .o_wb_data(wb32_sdio_idata),
		.i_card_detect(i_sdio_detect),
		.o_1p8v(w_sdio_1p8v),
		.o_int(sdio_int),
		//
		.o_cfg_ddr(o_sdio_cfg_ddr),
		.o_cfg_ds(o_sdio_cfg_ds),
		.o_cfg_dscmd(o_sdio_cfg_dscmd),
		.o_cfg_sample_shift(o_sdio_cfg_sample_shift),
		.o_pp_cmd(o_sdio_pp_cmd),
		.o_pp_data(o_sdio_pp_data),
		//
		.o_sdclk(   o_sdio_sdclk),
		.o_cmd_en(  o_sdio_cmd_en),
		.o_cmd_data(o_sdio_cmd_data),
		.o_data_en( o_sdio_data_en),
		.o_rx_en(   o_sdio_rx_en),
		.o_tx_data( o_sdio_tx_data),
		//
		.i_cmd_strb( i_sdio_cmd_strb),
		.i_cmd_data( i_sdio_cmd_data),
		.i_card_busy(i_sdio_card_busy),
		.i_rx_strb(  i_sdio_rx_strb),
		.i_rx_data(  i_sdio_rx_data),
		//
		.S_AC_VALID(i_sdio_ac_valid),
		.S_AC_DATA( i_sdio_ac_data),
		.S_AD_VALID(i_sdio_ad_valid),
		.S_AD_DATA( i_sdio_ad_data)
		// }}}
	);

	// }}}
	// }}}
`else	// SDIO_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_sdio peripheral
	// responding on the wb32 bus
	assign	wb32_sdio_ack   = 1'b0;
	assign	wb32_sdio_err   = (wb32_sdio_stb);
	assign	wb32_sdio_stall = 0;
	assign	wb32_sdio_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	sdio_int = 1'b0;	// sdio.INT.SDCARD.WIRE
	// }}}
	// }}}
`endif	// SDIO_ACCESS

`ifdef	GPIO_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// GPIO
	// {{{
	// This interface should allow us to control up to 16 GPIO inputs,
	// and another 16 GPIO outputs.  The interrupt trips when any of
	// the inputs changes.  (Sorry, which input isn't (yet) selectable.)
	//
	// Initially set:
	//	4x Test points to zero
	//	SI5324 reset to 0 (active)
	//	HDMI RX as *not* present
	//	*TRACE* defaults to OFF
	//	*ERROR* defaults to NONE (0)
	localparam [NGPO-1:0]	INITIAL_GPIO = 8'h20;

	wbgpio	#(
		.NIN(NGPI), .NOUT(NGPO), .DEFAULT(INITIAL_GPIO)
	) gpioi(
		// {{{
		i_clk, wb32_gpio_cyc, wb32_gpio_stb, wb32_gpio_we,
			wb32_gpio_data, // 32 bits wide
			wb32_gpio_sel,  // 32/8 bits wide
		wb32_gpio_stall, wb32_gpio_ack, wb32_gpio_idata,
		i_gpio, o_gpio, gpio_int
		// }}}
	);

	// }}}
	// }}}
`else	// GPIO_ACCESS
	// {{{
	// Null interrupt definitions
	// {{{
	assign	gpio_int = 1'b0;	// gpio.INT.GPIO.WIRE
	// }}}
	// }}}
`endif	// GPIO_ACCESS

`ifdef	CFG_ACCESS
	// {{{
`ifdef	VERILATOR
	reg	r_cfg_ack;

	initial	r_cfg_ack = 1'b0;
	always @(posedge i_clk)
		r_cfg_ack <= wb32_cfg_stb;
	assign	wb32_cfg_ack   = r_cfg_ack;
	assign	wb32_cfg_stall = 1'b0;
	assign	wb32_cfg_idata = 32'h00;

	assign	cfg_debug = 32'h00;

	// Verilator lint_off UNUSED
	wire	cfg_unused;
	assign	cfg_unused = &{ 1'b0, ICAPE_LGDIV[31:0] };
	// Verilator lint_on  UNUSED
`else
	wbicapetwo #(
		.LGDIV(ICAPE_LGDIV)
	) u_cfg(
		.i_clk(i_clk),
		.i_wb_cyc(wb32_cfg_cyc), .i_wb_stb(wb32_cfg_stb), .i_wb_we(wb32_cfg_we),
			.i_wb_addr(wb32_cfg_addr[5-1:0]),
			.i_wb_data(wb32_cfg_data), // 32 bits wide
			.i_wb_sel(wb32_cfg_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_cfg_stall),.o_wb_ack(wb32_cfg_ack), .o_wb_data(wb32_cfg_idata),
		.o_dbg(cfg_debug)
	);
`endif
	// }}}
`else	// CFG_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_cfg peripheral
	// responding on the wb32 bus
	assign	wb32_cfg_ack   = 1'b0;
	assign	wb32_cfg_err   = (wb32_cfg_stb);
	assign	wb32_cfg_stall = 0;
	assign	wb32_cfg_idata = 0;

	// }}}
	// }}}
`endif	// CFG_ACCESS

`ifdef	WBUBUS_MASTER
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// WBUBUS: USB-UART driven bus master and console
	// {{{
	// The Host USB interface, to be used by the WB-UART bus
	rxuartlite	#(
		// {{{
		.TIMER_BITS(DBGBUSBITS),
		.CLOCKS_PER_BAUD(BUSUART[DBGBUSBITS-1:0])
		// }}}
	) rcv(
		// {{{
		.i_clk(      i_clk),
		.i_uart_rx(i_wbu_uart_rx),
		.o_wr(       wbu_rx_stb),
		.o_data(     wbu_rx_data)
		// }}}
	);

	txuartlite	#(
		// {{{
		.TIMING_BITS(DBGBUSBITS[4:0]),
		.CLOCKS_PER_BAUD(BUSUART[DBGBUSBITS-1:0])
		// }}}
	) txv(
		// {{{
		.i_clk(    i_clk),
		.i_wr(     wbu_tx_stb),
		.i_data(   wbu_tx_data),
		.o_uart_tx(o_wbu_uart_tx),
		.o_busy(   wbu_tx_busy)
		// }}}
	);

	assign	o_wbu_uart_cts_n = 1'b0;

`ifndef	BUSPIC_ACCESS
	wire	w_bus_int;
`ifdef	INCLUDE_ZIPCPU
	assign	w_bus_int = zip_cpu_int;
`else
	assign	w_bus_int = 1'b0;
`endif
`endif
	// Verilator lint_off UNUSED
	wire	[29:0]	wbu_tmp_addr;
	// Verilator lint_on  UNUSED
	wbuconsole #(
		// {{{
		.LGWATCHDOG(DBGBUSWATCHDOG)
		// }}}
	) genbus(
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
		.i_rx_stb(wbu_rx_stb), .i_rx_data(wbu_rx_data),
		.o_wb_cyc(wbu_cyc), .o_wb_stb(wbu_stb),
			.o_wb_we(wbu_we),
			.o_wb_addr(wbu_tmp_addr),
			.o_wb_data(wbu_data),
		.i_wb_stall(wbu_stall),
			.i_wb_ack(wbu_ack),
		.i_wb_data(wbu_idata),
		.i_wb_err(wbu_err),
		.i_interrupt(w_bus_int),
		.o_tx_stb(wbu_tx_stb), .o_tx_data(wbu_tx_data),
			.i_tx_busy(wbu_tx_busy),
		//
`ifdef	SMI_CONSOLE
		.i_console_stb(w_console_tx_stb || smi_console_valid),
			.i_console_data(smi_console_valid ? smi_console_data[6:0]
					: w_console_tx_data),
`else
		.i_console_stb(w_console_tx_stb),
			.i_console_data(w_console_tx_data),
`endif
			.o_console_busy(w_console_busy),
		.o_console_stb(w_console_rx_stb),
			.o_console_data(w_console_rx_data),
		//
		.o_dbg(wbubus_dbg[0])
		// }}}
	);

`ifdef	SMI_CONSOLE
	assign	smi_console_ready = !w_console_busy;
`endif

	assign	wbu_sel = 4'hf;
	assign	wbu_addr = wbu_tmp_addr[(30-1):0];
	// }}}
	// }}}
`else	// WBUBUS_MASTER
	// {{{
	// Null bus master
	// {{{
	// }}}
	// }}}
`endif	// WBUBUS_MASTER

`ifdef	VERSION_ACCESS
	// {{{
	assign	wb32_version_idata = `DATESTAMP;
	assign	wb32_version_ack = wb32_version_stb;
	assign	wb32_version_stall = 1'b0;
	// }}}
`else	// VERSION_ACCESS
	// {{{
	// }}}
`endif	// VERSION_ACCESS

`ifdef	INCLUDE_ZIPCPU
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// The ZipCPU/ZipSystem BUS master
	// {{{
	//
	assign	zip_int_vector = { alt_int_vector[14:8], sys_int_vector[14:6] };
	zipsystem #(
		// {{{
		.RESET_ADDRESS(RESET_ADDRESS),
		.ADDRESS_WIDTH(ZIP_ADDRESS_WIDTH + $clog2(512/8)),
		.BUS_WIDTH(512),
		.OPT_LGICACHE(10),
		.OPT_LGDCACHE(10),
		.START_HALTED(ZIP_START_HALTED),
		.RESET_DURATION(20),
		.OPT_PIPELINED(1),
`ifdef INCLUDE_DMA_CONTROLLER
		.OPT_DMA(1'b1),
`else
		.OPT_DMA(1'b0),
`endif
`ifdef INCLUDE_ACCOUNTING_COUNTERS
		.OPT_ACCOUNTING(1'b1),
`else
		.OPT_ACCOUNTING(1'b0),
`endif
`ifdef	VERILATOR
		.OPT_PROFILER(1'b1),
`else
		.OPT_PROFILER(1'b0),
`endif
`ifdef	ZIPSCOPE_SCOPE
		.OPT_TRACE_PORT(1'b1),
`else
		.OPT_TRACE_PORT(1'b0),
`endif
		.OPT_DISTRIBUTED_REGS(1),
		.EXTERNAL_INTERRUPTS(ZIP_INTS)
		// }}}
	) swic(
		// {{{
		.i_clk(i_clk), .i_reset(i_reset || i_cpu_reset),
			// Zipsys wishbone interface
			.o_wb_cyc(wbwide_zip_cyc), .o_wb_stb(wbwide_zip_stb), .o_wb_we(wbwide_zip_we),
			.o_wb_addr(wbwide_zip_addr[25-1:0]),
			.o_wb_data(wbwide_zip_data), // 512 bits wide
			.o_wb_sel(wbwide_zip_sel),  // 512/8 bits wide
		.i_wb_stall(wbwide_zip_stall), .i_wb_ack(wbwide_zip_ack), .i_wb_data(wbwide_zip_idata), .i_wb_err(wbwide_zip_err),
			.i_ext_int(zip_int_vector), .o_ext_int(zip_cpu_int),
			// Debug wishbone interface
			.i_dbg_cyc(wbu_zip_cyc || cpu_sim_cyc),
			.i_dbg_stb(cpu_sim_cyc ? cpu_sim_stb : wbu_zip_stb),
			.i_dbg_we( cpu_sim_cyc ? cpu_sim_we  : wbu_zip_we),
			.i_dbg_addr(cpu_sim_cyc? cpu_sim_addr : wbu_zip_addr[6:0]),
			.i_dbg_data (cpu_sim_cyc? cpu_sim_data : wbu_zip_data),
			.i_dbg_sel  (cpu_sim_cyc? 4'hf : wbu_zip_sel),
			.o_dbg_stall(raw_cpu_dbg_stall),
			.o_dbg_ack  (raw_cpu_dbg_ack),
			.o_dbg_data (wbu_zip_idata),
			//
			.o_cpu_debug(zip_debug),
			.o_prof_stb(cpu_prof_stb),
			.o_prof_addr(cpu_prof_addr),
			.o_prof_ticks(cpu_prof_ticks)
		// }}}
	);
	assign	zip_trigger = zip_debug[31];

	assign	wbu_zip_stall =  cpu_sim_cyc || raw_cpu_dbg_stall;
	assign	wbu_zip_ack   = !cpu_sim_cyc && raw_cpu_dbg_ack;
	assign	cpu_sim_stall = !cpu_sim_cyc || raw_cpu_dbg_stall;
	assign	cpu_sim_ack   =  cpu_sim_cyc && raw_cpu_dbg_ack;
	assign	cpu_sim_idata = wbu_zip_idata;

	// Keep Verilator happy
	// {{{
	// Verilator lint_off UNUSED
	wire	zip_unused;
	assign	zip_unused = &{ 1'b0,
			alt_int_vector[7:0], sys_int_vector[5:0]};
	// Verilator lint_on  UNUSED
	// }}}
	// }}}
	// }}}
`else	// INCLUDE_ZIPCPU
	// {{{
	// Null bus master
	// {{{
	// }}}
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbu_zip peripheral
	// responding on the wbu bus
	assign	wbu_zip_ack   = 1'b0;
	assign	wbu_zip_err   = (wbu_zip_stb);
	assign	wbu_zip_stall = 0;
	assign	wbu_zip_idata = 0;

	// }}}
	// }}}
`endif	// INCLUDE_ZIPCPU

`ifdef	SIREFCLK_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// Generated clock handling
	// {{{
	//
	// Set to 0x2f85_1ec0 for 148.5MHz
	//
	initial	r_sirefclk_en   = 1'b0;
	initial	r_sirefclk_data = 30'd20000;
	always @(posedge i_clk)
	if (wb32_sirefclk_stb && wb32_sirefclk_we)
	begin
		if (wb32_sirefclk_sel[0])
			r_sirefclk_data[ 7: 0] <= wb32_sirefclk_data[ 7:0];
		if (wb32_sirefclk_sel[1])
			r_sirefclk_data[15: 8] <= wb32_sirefclk_data[15:8];
		if (wb32_sirefclk_sel[2])
			r_sirefclk_data[23:16] <= wb32_sirefclk_data[23:16];
		if (wb32_sirefclk_sel[3])
		begin
			r_sirefclk_en <= !wb32_sirefclk_data[31];
			r_sirefclk_data[29:24]<= wb32_sirefclk_data[29:24];
		end
	end

	always @(posedge i_clk)
	if (i_reset)
		r_sirefclk_ack <= 1'b0;
	else
		r_sirefclk_ack <= wb32_sirefclk_stb;

	assign	wb32_sirefclk_ack   = r_sirefclk_ack;
	assign	wb32_sirefclk_stall = 1'b0;
	assign	wb32_sirefclk_idata = { !r_sirefclk_en,
						1'b0, r_sirefclk_data };
	assign	o_sirefclk_ce = r_sirefclk_en;

	genclk
	clock_generator(
		.i_clk(i_clk),
		.i_delay({ 2'b00, r_sirefclk_data[29:0] }),
		.o_word(o_sirefclk_word),
		.o_stb(w_sirefclk_unused_stb)
	);
	// }}}
	// }}}
`else	// SIREFCLK_ACCESS
	// {{{
	// }}}
`endif	// SIREFCLK_ACCESS

	assign	wb32_netlock_stall = 1'b0;
	assign	wb32_netlock_ack = wb32_netlock_stb;
	assign	wb32_netlock_idata = { {(16){1'b0}},
			{(8-NETDEVS){1'b0}}, r_netlock_los,
			{(8-NETDEVS-1){1'b0}}, r_netlock_phy_locked };

	always @(posedge i_clk)
	begin
		r_netlock_los        <= i_gnet_los;
		r_netlock_phy_locked <= i_gnet_phy_locked;
	end
	wbdown #(
		// {{{
		.ADDRESS_WIDTH(9+$clog2(32/8)),
		.WIDE_DW(512),
		.SMALL_DW(32),
		.OPT_LITTLE_ENDIAN(1'b0),
		.OPT_LOWLOGIC(1'b0)
		// }}}
	) u_wbdown (
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		// Slave/incoming
		// {{{
		.i_wcyc(  wbwide_wbdown_cyc),
		.i_wstb(  wbwide_wbdown_stb),
		.i_wwe(   wbwide_wbdown_we),
		.i_waddr( wbwide_wbdown_addr[5-1:0]),
		.i_wdata( wbwide_wbdown_data),
		.i_wsel(  wbwide_wbdown_sel),
		.o_wstall(wbwide_wbdown_stall),
		.o_wack(  wbwide_wbdown_ack),
		.o_wdata( wbwide_wbdown_idata),
		.o_werr(  wbwide_wbdown_err),
		// }}}
		// Master/down-range/outgoing
		// {{{
		.o_scyc(  wb32_wbdown_cyc),
		.o_sstb(  wb32_wbdown_stb),
		.o_swe(   wb32_wbdown_we),
		.o_saddr( wb32_wbdown_addr[9-1:0]),
		.o_sdata( wb32_wbdown_data),
		.o_ssel(  wb32_wbdown_sel),
		.i_sstall(wb32_wbdown_stall),
		.i_sack(  wb32_wbdown_ack),
		.i_sdata( wb32_wbdown_idata),
		.i_serr(  wb32_wbdown_err)
		// }}}
		// }}}
	);
`ifdef	SICLK
	// {{{
	clkcounter
	u_siclk (
		.i_sys_clk(i_clk), .i_tst_clk(i_siclk),
		.i_sys_pps(1'b0), .o_sys_counts(wb32_siclk_idata)
	);

	assign	wb32_siclk_stall = 1'b0;
	assign	wb32_siclk_ack   = wb32_siclk_stb;
	// }}}
`else	// SICLK
	// {{{
	// }}}
`endif	// SICLK

	assign	wb32_buildtime_idata = `BUILDTIME;
	assign	wb32_buildtime_ack = wb32_buildtime_stb;
	assign	wb32_buildtime_stall = 1'b0;
`ifdef	BUSCONSOLE_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// WBUBUS: Console instantiations
	// {{{
	wbconsole #(.LGFLEN(6)
	) console(
		// {{{
		.i_clk(i_clk), .i_reset(1'b0),
		.i_wb_cyc(wb32_uart_cyc), .i_wb_stb(wb32_uart_stb), .i_wb_we(wb32_uart_we),
			.i_wb_addr(wb32_uart_addr[2-1:0]),
			.i_wb_data(wb32_uart_data), // 32 bits wide
			.i_wb_sel(wb32_uart_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_uart_stall),.o_wb_ack(wb32_uart_ack), .o_wb_data(wb32_uart_idata),
		.o_uart_stb(w_console_tx_stb), .o_uart_data(w_console_tx_data),
`ifdef	SMI_CONSOLE
			.i_uart_busy(w_console_busy || smi_console_valid),
`else
			.i_uart_busy(w_console_busy),
`endif
		.i_uart_stb(w_console_rx_stb), .i_uart_data(w_console_rx_data),
		.o_uart_rx_int(uartrx_int), .o_uart_tx_int(uarttx_int),
		.o_uart_rxfifo_int(uartrxf_int),.o_uart_txfifo_int(uarttxf_int),
		.o_debug(uart_debug)
		// }}}
	);
	// }}}
	// }}}
`else	// BUSCONSOLE_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_uart peripheral
	// responding on the wb32 bus
	assign	wb32_uart_ack   = 1'b0;
	assign	wb32_uart_err   = (wb32_uart_stb);
	assign	wb32_uart_stall = 0;
	assign	wb32_uart_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	uartrxf_int = 1'b0;	// uart.INT.UARTRXF.WIRE
	assign	uarttx_int = 1'b0;	// uart.INT.UARTTX.WIRE
	assign	uarttxf_int = 1'b0;	// uart.INT.UARTTXF.WIRE
	assign	uartrx_int = 1'b0;	// uart.INT.UARTRX.WIRE
	// }}}
	// }}}
`endif	// BUSCONSOLE_ACCESS

`ifdef	EMMC_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// eMMC Card handling
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	//

	sdio #(
		// {{{
		.LGFIFO(10), .NUMIO(8),
		.MW(32),
		.OPT_SERDES(1'b0),
		.OPT_DDR(1'b0),
		.OPT_CARD_DETECT(1'b0),
		.OPT_EMMC(1'b1)
		// }}}
	) u_emmc(
		// {{{
		.i_clk(i_clk),
		.i_reset(i_reset),
		.i_wb_cyc(wb32_emmc_cyc), .i_wb_stb(wb32_emmc_stb), .i_wb_we(wb32_emmc_we),
			.i_wb_addr(wb32_emmc_addr[3-1:0]),
			.i_wb_data(wb32_emmc_data), // 32 bits wide
			.i_wb_sel(wb32_emmc_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_emmc_stall),.o_wb_ack(wb32_emmc_ack), .o_wb_data(wb32_emmc_idata),
		.i_card_detect(i_emmc_detect),
		.o_1p8v(w_emmc_1p8v),
		.o_int(emmc_int),
		//
		.o_cfg_ddr(o_emmc_cfg_ddr),
		.o_cfg_ds(o_emmc_cfg_ds),
		.o_cfg_dscmd(o_emmc_cfg_dscmd),
		.o_cfg_sample_shift(o_emmc_cfg_sample_shift),
		.o_pp_cmd(o_emmc_pp_cmd),
		.o_pp_data(o_emmc_pp_data),
		//
		.o_sdclk(   o_emmc_sdclk),
		.o_cmd_en(  o_emmc_cmd_en),
		.o_cmd_data(o_emmc_cmd_data),
		.o_data_en( o_emmc_data_en),
		.o_rx_en(   o_emmc_rx_en),
		.o_tx_data( o_emmc_tx_data),
		//
		.i_cmd_strb( i_emmc_cmd_strb),
		.i_cmd_data( i_emmc_cmd_data),
		.i_card_busy(i_emmc_card_busy),
		.i_rx_strb(  i_emmc_rx_strb),
		.i_rx_data(  i_emmc_rx_data),
		//
		.S_AC_VALID(i_emmc_ac_valid),
		.S_AC_DATA( i_emmc_ac_data),
		.S_AD_VALID(i_emmc_ad_valid),
		.S_AD_DATA( i_emmc_ad_data)
		// }}}
	);

	// }}}
	// }}}
`else	// EMMC_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_emmc peripheral
	// responding on the wb32 bus
	assign	wb32_emmc_ack   = 1'b0;
	assign	wb32_emmc_err   = (wb32_emmc_stb);
	assign	wb32_emmc_stall = 0;
	assign	wb32_emmc_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	emmc_int = 1'b0;	// emmc.INT.EMMC.WIRE
	// }}}
	// }}}
`endif	// EMMC_ACCESS

`ifdef	BKRAM_ACCESS
	// {{{
	memdev #(
		.LGMEMSZ(19),
		.DW(512),
		.EXTRACLOCK(1)
	) bkrami(
		.i_clk(i_clk),
		.i_reset(i_reset),
		.i_wb_cyc(wbwide_bkram_cyc), .i_wb_stb(wbwide_bkram_stb), .i_wb_we(wbwide_bkram_we),
			.i_wb_addr(wbwide_bkram_addr[13-1:0]),
			.i_wb_data(wbwide_bkram_data), // 512 bits wide
			.i_wb_sel(wbwide_bkram_sel),  // 512/8 bits wide
		.o_wb_stall(wbwide_bkram_stall),.o_wb_ack(wbwide_bkram_ack), .o_wb_data(wbwide_bkram_idata)
	);
	// }}}
`else	// BKRAM_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbwide_bkram peripheral
	// responding on the wbwide bus
	assign	wbwide_bkram_ack   = 1'b0;
	assign	wbwide_bkram_err   = (wbwide_bkram_stb);
	assign	wbwide_bkram_stall = 0;
	assign	wbwide_bkram_idata = 0;

	// }}}
	// }}}
`endif	// BKRAM_ACCESS

`ifdef	DDR3_CONTROLLER_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// DDR3 Controller instantiation
	// {{{
	ddr3_controller #(
            .CONTROLLER_CLK_PERIOD(DDR3_CONTROLLERCONTROLLER_CLK_PERIOD), //ns, period of clock input to this DDR3 controller module
            .DDR3_CLK_PERIOD(DDR3_CLK_PERIOD), //ns, period of clock input to DDR3 RAM device
            .ROW_BITS(DDR3_CONTROLLERROW_BITS), //width of row address
            .COL_BITS(DDR3_CONTROLLERCOL_BITS), //width of column address
            .BA_BITS(DDR3_CONTROLLERBA_BITS), //width of bank address
            .DQ_BITS(DDR3_CONTROLLERDQ_BITS),  //width of DQ
            .LANES(DDR3_CONTROLLERLANES), //8 lanes of DQ
            .AUX_WIDTH(DDR3_CONTROLLERAUX_WIDTH), //
            .MICRON_SIM(0), //simulation for micron ddr3 model (shorten POWER_ON_RESET_HIGH and INITIAL_CKE_LOW)
            .ODELAY_SUPPORTED(1), //set to 1 when ODELAYE2 is supported
            .OPT_LOWPOWER(1), //1 = low power, 0 = low logic
            .OPT_BUS_ABORT(1)  //1 = can abort bus, 0 = no abort (i_wb_cyc will be ignored, ideal for an AXI implementation which cannot abort transaction)
	) ddr3_controller_inst (
            .i_controller_clk(i_clk), //i_controller_clk has period of CONTROLLER_CLK_PERIOD
            .i_rst_n(!i_reset), //200MHz input clock
            // Wishbone 1 (Controller)
            .i_wb_cyc(wbwide_ddr3_controller_cyc), .i_wb_stb(wbwide_ddr3_controller_stb), .i_wb_we(wbwide_ddr3_controller_we),
			.i_wb_addr(wbwide_ddr3_controller_addr[24-1:0]),
			.i_wb_data(wbwide_ddr3_controller_data), // 512 bits wide
			.i_wb_sel(wbwide_ddr3_controller_sel),  // 512/8 bits wide
		.o_wb_stall(wbwide_ddr3_controller_stall),.o_wb_ack(wbwide_ddr3_controller_ack), .o_wb_data(wbwide_ddr3_controller_idata),
            .i_aux(0),
            .o_aux(ddr3_controller_aux_out),	// Leaving this empty would've caused a Verilator warning
            // Wishbone 2 (PHY)
            .i_wb2_cyc(wb32_ddr3_phy_cyc), .i_wb2_stb(wb32_ddr3_phy_stb), .i_wb2_we(wb32_ddr3_phy_we),
			.i_wb2_addr(wb32_ddr3_phy_addr[7-1:0]),
			.i_wb2_data(wb32_ddr3_phy_data), // 32 bits wide
			.i_wb2_sel(wb32_ddr3_phy_sel),  // 32/8 bits wide
		.o_wb2_stall(wb32_ddr3_phy_stall),.o_wb2_ack(wb32_ddr3_phy_ack), .o_wb2_data(wb32_ddr3_phy_idata),
            //
            // PHY interface
            .i_phy_iserdes_data(i_ddr3_controller_iserdes_data),
            .i_phy_iserdes_dqs(i_ddr3_controller_iserdes_dqs),
            .i_phy_iserdes_bitslip_reference(i_ddr3_controller_iserdes_bitslip_reference),
            .i_phy_idelayctrl_rdy(i_ddr3_controller_idelayctrl_rdy),
            .o_phy_cmd(o_ddr3_controller_cmd),
            .o_phy_dqs_tri_control(o_ddr3_controller_dqs_tri_control),
            .o_phy_dq_tri_control(o_ddr3_controller_dq_tri_control),
            .o_phy_toggle_dqs(o_ddr3_controller_toggle_dqs),
            .o_phy_data(o_ddr3_controller_data),
            .o_phy_dm(o_ddr3_controller_dm),
            .o_phy_odelay_data_cntvaluein(o_ddr3_controller_odelay_data_cntvaluein),
            .o_phy_odelay_dqs_cntvaluein(o_ddr3_controller_odelay_dqs_cntvaluein),
            .o_phy_idelay_data_cntvaluein(o_ddr3_controller_idelay_data_cntvaluein),
            .o_phy_idelay_dqs_cntvaluein(o_ddr3_controller_idelay_dqs_cntvaluein),
            .o_phy_odelay_data_ld(o_ddr3_controller_odelay_data_ld),
            .o_phy_odelay_dqs_ld(o_ddr3_controller_odelay_dqs_ld),
            .o_phy_idelay_data_ld(o_ddr3_controller_idelay_data_ld),
            .o_phy_idelay_dqs_ld(o_ddr3_controller_idelay_dqs_ld),
            .o_phy_bitslip(o_ddr3_controller_bitslip),
            .o_phy_write_leveling_calib(o_ddr3_controller_leveling_calib),
            .o_phy_reset(o_ddr3_controller_reset),
            // Debug port
            .o_debug1(ddr3_controller_debug1),
            .o_debug2(ddr3_controller_debug2),
            .o_debug3(ddr3_controller_debug3)
        );
	// }}}
	// }}}
`else	// DDR3_CONTROLLER_ACCESS
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wbwide_ddr3_controller peripheral
	// responding on the wbwide bus
	assign	wbwide_ddr3_controller_ack   = 1'b0;
	assign	wbwide_ddr3_controller_err   = (wbwide_ddr3_controller_stb);
	assign	wbwide_ddr3_controller_stall = 0;
	assign	wbwide_ddr3_controller_idata = 0;

	// }}}
	// }}}
`endif	// DDR3_CONTROLLER_ACCESS

`ifdef	NETRESET_ACCESS
	// {{{
	initial	r_netreset=0;
	always @(posedge i_clk)
	if (i_reset)
		r_netreset <= 0;
	else if (wb32_netreset_stb && wb32_netreset_we
			&& (wb32_netreset_sel[0]))
		r_netreset <= wb32_netreset_data[NETPORTS-1:0];

	assign	wb32_netreset_stall=1'b0;
	assign	wb32_netreset_ack=wb32_netreset_stb;
	assign	wb32_netreset_idata={ {(32-NETPORTS){1'b0}}, r_netreset };
	// }}}
`else	// NETRESET_ACCESS
	// {{{
	initial	r_netreset=0;
	always @(*)
		r_netreset = {(NETPORTS){i_reset)};
	// }}}
`endif	// NETRESET_ACCESS

`ifdef	ETH_ROUTER
	// {{{
	generate for(g_gnet=0; g_gnet<NETDEVS; g_gnet=g_gnet+1)
	begin : GEN_ETHERNET_DECODE
		netpath
		u_netpath (
			// {{{
			.i_sys_clk(i_clk),
			.i_fast_clk(i_clk200),
			.i_reset_n(!i_reset),
			.i_rx_clk(i_gnet_rx_clk[g_gnet]),
			.i_tx_clk(i_gnet_tx_clk[g_gnet]),
			.o_link_up(o_gnet_linkup[g_gnet]),
			.o_activity(o_gnet_activity[g_gnet]),
			// PHY interface
			// {{{
			.i_phy_fault(i_gnet_phy_fault[g_gnet]),
			.i_raw_data(i_gnet_rx_data[32*g_gnet+:32]
							^ 32'hffff_ffff),
			//
			.o_raw_data(o_gnet_tx_data[32*g_gnet+:32]),
			// }}}
			// Incoming (received) packet AXIN source
			// {{{
			.M_VALID(gnet_rx_valid[g_gnet]),
			.M_READY(gnet_rx_ready[g_gnet]),
			.M_DATA( gnet_rx_data[128*g_gnet+: 128]),
			.M_BYTES(gnet_rx_bytes[4*g_gnet+: 4]),
			.M_LAST( gnet_rx_last[g_gnet]),
			.M_ABORT(gnet_rx_abort[g_gnet]),
			// }}}
			// Outgoing (transmit) packet AXIN sink
			// {{{
			.S_VALID(gnet_tx_valid[g_gnet]),
			.S_READY(gnet_tx_ready[g_gnet]),
			.S_DATA( gnet_tx_data[128*g_gnet+: 128]),
			.S_BYTES(gnet_tx_bytes[4*g_gnet+: 4]),
			.S_LAST( gnet_tx_last[g_gnet]),
			.S_ABORT(gnet_tx_abort[g_gnet]),
			// }}}
			.o_debug(gnet_net_debug[32*g_gnet +: 32])
			// }}}
		);
	end endgenerate

	////////////////////////////////////////////////////////////////////////
	//
	// Instantiate the core of the router itself
	// {{{

	routecore #(
		.NETH(NETPORTS),
`ifdef	CPUNET_ACCESS
		.OPT_CPUNET(1'b1),
`else
		.OPT_CPUNET(1'b0),
`endif
		.DEF_BASEADDR(0),
		.DEF_MEMSIZE(0),
		.BUSDW(512),
		.AW(25),
		.OPT_VFIFO(4'b1100)
`ifdef	CPUNET_ACCESS
		// This *should* work, but ... doesn't
		, .OPT_NEVER({ 5'h10, 5'h08, 5'h04, 5'h1f, 5'h1f }),
		.OPT_ALWAYS({ 5'h00, 5'h00, 5'h00, 5'h00, 5'h00 })
//
		// This should force a "right" answer
		// , .OPT_NEVER({ 5'h10, 5'h1f, 5'h1f, 5'h1f, 5'h1f }),
		// .OPT_ALWAYS({ 5'h00, 5'h04, 5'h08, 5'h00, 5'h00 })
`endif
	) u_router (
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
`ifdef	NETRESET_ACCESS
		.ETH_RESET(r_netreset),
`else
		.ETH_RESET({(NETPORTS){i_reset}}),
`endif
		// Incoming (RX) packet interface
		// {{{
`ifdef	CPUNET_ACCESS
		.RX_VALID({ cpunet_tx_valid, gnet_rx_valid }),
		.RX_READY({ cpunet_tx_ready, gnet_rx_ready }),
		.RX_DATA({  cpunet_tx_data,  gnet_rx_data  }),
		.RX_BYTES({ cpunet_tx_bytes, gnet_rx_bytes }),
		.RX_LAST({  cpunet_tx_last,  gnet_rx_last  }),
		.RX_ABORT({ cpunet_tx_abort, gnet_rx_abort }),
`else
		.RX_VALID(gnet_rx_valid),
		.RX_READY(gnet_rx_ready),
		.RX_DATA( gnet_rx_data),
		.RX_BYTES(gnet_rx_bytes),
		.RX_LAST( gnet_rx_last),
		.RX_ABORT(gnet_rx_abort),
`endif
		// }}}
		// VFIFO control interface
		.i_ctrl_cyc(wb32_gnet_cyc), .i_ctrl_stb(wb32_gnet_stb), .i_ctrl_we(wb32_gnet_we),
			.i_ctrl_addr(wb32_gnet_addr[6-1:0]),
			.i_ctrl_data(wb32_gnet_data), // 32 bits wide
			.i_ctrl_sel(wb32_gnet_sel),  // 32/8 bits wide
		.o_ctrl_stall(wb32_gnet_stall),.o_ctrl_ack(wb32_gnet_ack), .o_ctrl_data(wb32_gnet_idata),
		// VFIFO memory interface
		.o_vfifo_cyc(wbwide_gnet_cyc), .o_vfifo_stb(wbwide_gnet_stb), .o_vfifo_we(wbwide_gnet_we),
			.o_vfifo_addr(wbwide_gnet_addr[25-1:0]),
			.o_vfifo_data(wbwide_gnet_data), // 512 bits wide
			.o_vfifo_sel(wbwide_gnet_sel),  // 512/8 bits wide
		.i_vfifo_stall(wbwide_gnet_stall), .i_vfifo_ack(wbwide_gnet_ack), .i_vfifo_data(wbwide_gnet_idata), .i_vfifo_err(wbwide_gnet_err),
		// Outgoing (TX) packet interface
		// {{{
`ifdef	CPUNET_ACCESS
		.TX_VALID({ cpunet_rx_valid, gnet_tx_valid }),
		.TX_READY({ cpunet_rx_ready, gnet_tx_ready }),
		.TX_DATA({  cpunet_rx_data,  gnet_tx_data  }),
		.TX_BYTES({ cpunet_rx_bytes, gnet_tx_bytes }),
		.TX_LAST({  cpunet_rx_last,  gnet_tx_last  }),
		.TX_ABORT({ cpunet_rx_abort, gnet_tx_abort }),
`else
		.TX_VALID(gnet_tx_valid),
		.TX_READY(gnet_tx_ready),
		.TX_DATA( gnet_tx_data),
		.TX_BYTES(gnet_tx_bytes),
		.TX_LAST( gnet_tx_last),
		.TX_ABORT(gnet_tx_abort),
`endif
		// }}}
		.o_debug(gnet_route_debug)
		// }}}
	);

	// }}}
	// }}}
`else	// ETH_ROUTER
	// {{{
	// Null bus master
	// {{{
	// }}}
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_gnet peripheral
	// responding on the wb32 bus
	assign	wb32_gnet_ack   = 1'b0;
	assign	wb32_gnet_err   = (wb32_gnet_stb);
	assign	wb32_gnet_stall = 0;
	assign	wb32_gnet_idata = 0;

	// }}}
	// }}}
`endif	// ETH_ROUTER

`ifdef	CPUNET_ACCESS
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	// CPU Network
	// {{{

	cpunet #(
		.AW(25),
		.BUSDW(512),
		.PKTDW(128)
	) u_cpunet (
		// {{{
		.i_clk(i_clk), .i_reset(i_reset),
		.i_wb_cyc(wb32_cpunets_cyc), .i_wb_stb(wb32_cpunets_stb), .i_wb_we(wb32_cpunets_we),
			.i_wb_addr(wb32_cpunets_addr[5-1:0]),
			.i_wb_data(wb32_cpunets_data), // 32 bits wide
			.i_wb_sel(wb32_cpunets_sel),  // 32/8 bits wide
		.o_wb_stall(wb32_cpunets_stall),.o_wb_ack(wb32_cpunets_ack), .o_wb_data(wb32_cpunets_idata),
		//
		.RX_VALID(cpunet_rx_valid),
		.RX_READY(cpunet_rx_ready),
		.RX_DATA( cpunet_rx_data),
		.RX_BYTES(cpunet_rx_bytes),
		.RX_LAST( cpunet_rx_last),
		.RX_ABORT(cpunet_rx_abort),
		//
		.TX_VALID(cpunet_tx_valid),
		.TX_READY(cpunet_tx_ready),
		.TX_DATA( cpunet_tx_data),
		.TX_BYTES(cpunet_tx_bytes),
		.TX_LAST( cpunet_tx_last),
		.TX_ABORT(cpunet_tx_abort),
		//
		.o_dma_cyc(wbwide_cpunetm_cyc), .o_dma_stb(wbwide_cpunetm_stb), .o_dma_we(wbwide_cpunetm_we),
			.o_dma_addr(wbwide_cpunetm_addr[25-1:0]),
			.o_dma_data(wbwide_cpunetm_data), // 512 bits wide
			.o_dma_sel(wbwide_cpunetm_sel),  // 512/8 bits wide
		.i_dma_stall(wbwide_cpunetm_stall), .i_dma_ack(wbwide_cpunetm_ack), .i_dma_data(wbwide_cpunetm_idata), .i_dma_err(wbwide_cpunetm_err),
		//
		.o_rx_int(cpunet_rx_int),
		.o_tx_int(cpunet_tx_int),
		.o_debug(cpunet_debug)
		// }}}
	);

	// }}}
	// }}}
`else	// CPUNET_ACCESS
	// {{{
	assign	cpunet_rx_valid = 0;
	assign	cpunet_rx_ready = 1;
	assign	cpunet_rx_last  = 0;
	assign	cpunet_rx_abort = 0;
	assign	cpunet_rx_data  = 0;
	assign	cpunet_rx_bytes = 0;

	assign	cpunet_tx_valid = 0;
	assign	cpunet_tx_ready = 1;
	assign	cpunet_tx_last  = 0;
	assign	cpunet_tx_abort = 0;
	assign	cpunet_tx_data  = 0;
	assign	cpunet_tx_bytes = 0;
	// Null bus master
	// {{{
	// }}}
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_cpunets peripheral
	// responding on the wb32 bus
	assign	wb32_cpunets_ack   = 1'b0;
	assign	wb32_cpunets_err   = (wb32_cpunets_stb);
	assign	wb32_cpunets_stall = 0;
	assign	wb32_cpunets_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	cpunet_tx_int = 1'b0;	// cpunet.INT.TXNET.WIRE
	assign	cpunet_rx_int = 1'b0;	// cpunet.INT.RXNET.WIRE
	// }}}
	// }}}
`endif	// CPUNET_ACCESS

`ifdef	ROUTESCOPE_SCOPC
	// {{{
	wbscopc #(
		// {{{
		.LGMEM(8),
		.SYNCHRONOUS(1),
		.DEFAULT_HOLDOFF(124)
		// }}}
	) routescopei(
		// {{{
		i_clk, 1'b1, gnet_route_debug[31], gnet_route_debug[30:0],
		i_clk,
		wb32_routescope_cyc, wb32_routescope_stb, wb32_routescope_we,
			wb32_routescope_addr[1-1:0],
			wb32_routescope_data, // 32 bits wide
			wb32_routescope_sel,  // 32/8 bits wide
		wb32_routescope_stall, wb32_routescope_ack, wb32_routescope_idata,
		routescope_int
		// }}}
	);
	// }}}
`else	// ROUTESCOPE_SCOPC
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_routescope peripheral
	// responding on the wb32 bus
	assign	wb32_routescope_ack   = 1'b0;
	assign	wb32_routescope_err   = (wb32_routescope_stb);
	assign	wb32_routescope_stall = 0;
	assign	wb32_routescope_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	routescope_int = 1'b0;	// routescope.INT.ROUTESCOPE.WIRE
	// }}}
	// }}}
`endif	// ROUTESCOPE_SCOPC

	assign	wb32_netdbg_stall = 0;
	always @(posedge i_clk)
	if (i_reset)
		netdbg_netdbg <= 0;
	else if (wb32_netdbg_stb && wb32_netdbg_we
			&& (&wb32_netdbg_sel[($clog2(NETDEVS)+7)/8-1:0]))
		netdbg_netdbg <= wb32_netdbg_data[$clog2(NETDEVS)-1:0];

	assign	netdbg_wide = gnet_net_debug >> (32* netdbg_netdbg);
	always @(posedge i_clk)
		net_debug <= netdbg_wide[31:0];
	always @(posedge i_clk)
		netdbg_netleds <= { o_gnet_activity, o_gnet_linkup };

	assign	wb32_netdbg_ack = wb32_netdbg_stb;
	assign	wb32_netdbg_idata = { 8'h00,
		{(8-NETDEVS){1'b0}}, netdbg_netleds[NETDEVS +: NETDEVS],
		{(8-NETDEVS){1'b0}}, netdbg_netleds[0 +: NETDEVS],
		{(8-$clog2(NETDEVS)){1'b0}}, netdbg_netdbg };

`ifdef	NETSCOPE_SCOPC
	// {{{
	wbscopc #(
		// {{{
		.LGMEM(10),
		.SYNCHRONOUS(1),
		.DEFAULT_HOLDOFF(508)
		// }}}
	) netscopei(
		// {{{
		i_clk, 1'b1, net_debug[31], net_debug[30:0],
		i_clk,
		wb32_netscope_cyc, wb32_netscope_stb, wb32_netscope_we,
			wb32_netscope_addr[1-1:0],
			wb32_netscope_data, // 32 bits wide
			wb32_netscope_sel,  // 32/8 bits wide
		wb32_netscope_stall, wb32_netscope_ack, wb32_netscope_idata,
		netscope_int
		// }}}
	);
	// }}}
`else	// NETSCOPE_SCOPC
	// {{{
	// Null bus slave
	// {{{

	//
	// In the case that there is no wb32_netscope peripheral
	// responding on the wb32 bus
	assign	wb32_netscope_ack   = 1'b0;
	assign	wb32_netscope_err   = (wb32_netscope_stb);
	assign	wb32_netscope_stall = 0;
	assign	wb32_netscope_idata = 0;

	// }}}
	// Null interrupt definitions
	// {{{
	assign	netscope_int = 1'b0;	// netscope.INT.NETSCOPE.WIRE
	// }}}
	// }}}
`endif	// NETSCOPE_SCOPC

	// }}}
endmodule // main.v
